\input{preamble.tex}
%\input{titlepage.tex}

\begin{document}

\newgeometry{left=3cm}
	\include{titlepage-content}
\restoregeometry

\pagenumbering{roman}

\clearpage
\vspace*{\fill}
\begin{center}
	\begin{minipage}{.8\textwidth}
		\thispagestyle{empty} % no pagenumber on affidavit
		Diese Arbeit ist von mir selbst\"andig angefertigt und verfasst. Es sind keine anderen als die angegebenen Quellen und Hilfsmittel benutzt worden.\par
		\vspace{1cm}
		Frederic Klein \dotfill \par
		Unterschrift
	\end{minipage}
\end{center}
\vfill % equivalent to \vspace{\fill}
\clearpage

\spacing{1.5} % line spacing

\begin{abstract}
	\thispagestyle{plain}
	\setcounter{page}{1}
	In recent years gamification has become a part in many areas of our daily routine. In regard to our personal life, companies like Amazon or Runtastic can base their gamification approach on publicly sharing personal achievements and statistics to improve user commitment. In contrast, gamification concerning our work life has to satisfy much higher privacy demands. Since comparison is a key component for gamification, privacy protecting computations of system wide statistical values (for example minimum and maximum) are needed. The solution comes in the form of \gls{SMPC}, a subfield of cryptography. Existing frameworks for \gls{SMPC} utilize the Internet Protocol, though access to the Internet or even a \gls{LAN} cannot be provided in all environments. Facilities with sensible measuring systems, e.g. medical devices in hospitals, often avoid Wi-Fi to reduce the risk of electromagnetic interference.
	To be able to utilize \gls{SMPC} in environments with Wi-Fi restrictions, this thesis studies the characteristics of \gls{MANET} and proposes the design of a \gls{SMPC} framework for \gls{MANET}, especially based on Bluetooth technology, and the implementation as a C library.
	
	Since \glspl{MANET} have a \todo*{bad word high acceptable here?} high probability for network partition, a centralized architecture for the computation and data preservation is unfavorable. Therefor a blockchain based distributed database is implemented in the framework. Typical problems of distributed systems are addressed with the implementation of algorithms for clock synchronization and coordinator election as well as protocols for the detection of computation partners and data distribution. Since the framework aims to provide distributed computations of comparable values, protocols for secure addition and secure comparison are implemented, enabling the computation of minimum, maximum and average.
	
	Devices of diverse computational power will be used to verify the applicability for wearables and \gls{IoT} grade devices. Also field-tests with a \gls{SPAN}(20-50 nodes) will be conducted to evaluated real life use cases. In contrast, the security of the framework and attack scenarios will be discussed. In summary, this thesis proposes a framework for \gls{SMPC} for decentralized, distributed systems.
\end{abstract}

\tableofcontents
\setcounter{page}{2}
\listoffigures
{\let\clearpage\relax \listoftables}

\printnoidxglossary[type=\acronymtype,title={List of Acronyms}]

{\let\clearpage\relax \printnoidxglossary[type=symbols,sort=letter]}


\chapter{Introduction} \label{Introduction}
\todo*{5-10\%, including motivation, general audience}

\pagenumbering{arabic}
%In the last couple of years gamification has found it's way into many areas of our daily life. In regard to our personal life, companies like Amazon or Runtastic can base their gamification approach on publicly sharing personal achievements and statistics to improve user commitment. In contrast, gamification concerning our work life can have much higher privacy demands. Since comparison is a key component for the gamification approach, privacy protecting computations of system wide statistical values (for example minimum and maximum) are needed. The solution comes in the form of \gls{SMPC}, a subfield of cryptography.

%Existing frameworks for \gls{SMPC} utilize the Internet protocol, though access to the Internet or even a \gls{LAN} cannot be provided in all environments. Especially many hospitals tend to avoid Wi-Fi to reduce the risk of electromagnetic interference with medical devices.

%To be able to utilize \gls{SMPC} in environments with Wi-Fi restrictions, this thesis studies the characteristics of mesh-networks and proposes describes the design of a \gls{SMPC} framework for mesh-networks.

%Context

\todo*{mention \gls{IoT} problems ( \gls{DDoS} and botnets), to emphasis usefulness of connected but not online}

%Restatement of the problem

%Restatement of the response

%Roadmap

\section{Case Study: "The Hygiene Games"} \label{Case Study: "The Hygiene Games"}

\paragraph{Gamification}

\paragraph{Wireless Networks in Hospitals}

\FloatBarrier



\chapter{Background} \label{Background}

\todo*{10-15\%; thorough review of the state of the art; informed audience}


In this chapter a general understanding of \gls{SMPC} and the key features of \glspl{MANET} is established.  

First the idea for \gls{SMPC} is introduced in \ref{Secure Multi-Party Computation} \nameref{Secure Multi-Party Computation}. Since secret sharing is used for the development of \gls{SMPC} protocols, Shamir's secret sharing scheme is presented in \ref{Secret Sharing} \nameref{Secret Sharing}.
Protocols for secure addition and secure comparison with passive security are introduced in \ref{Secure Addition Protocol} and \ref{Secure Comparison Protocol} and existing frameworks for \gls{SMPC} are briefly discussed in \ref{Existing Frameworks}.

To be able to define requirements for the new framework (see \ref{Requirements}), the key features of \glspl{MANET} are identified in \fullref{Mobile Ad Hoc Networks}, with a focus on the wireless technology standards Bluetooth and Wi-Fi and the differences to similar network types like mesh networks.

%Since the \gls{SMPC} protocols expect a secure communication channel, while a pairing-less connection doesn't provide security by default, public key cryptography is needed (see \ref{Securing the Communication Channel}). 
%The key generation, as well as Shamir's secret sharing scheme, requires random numbers. Computer systems can generate pseudo-random numbers and the randomness of such an \gls{PRNG} is discussed in\fullref{Communication Layer}.

\section{Secure Multi-Party Computation} \label{Secure Multi-Party Computation}

\todo*{general idea}
\gls{SMPC} is a subfield of cryptography. The target of \gls{SMPC} is to run computations over inputs from multiple parties while keeping these inputs secret. In 1982 Yao described the problem of two millionaires trying to find out, which one is wealthier, without giving each other information about their actual capital \autocite{Yao1982}. Yaos solution for this \gls{2PC} is considered to be the basis for general \gls{SMPC} protocols.
\textcite{Cramer2015} describe for example benchmark analysis as a use-cases for \gls{SMPC}: companies want to know how well they are doing in their business area compared to other companies, while they do not want to share their current business numbers with competitors. Using a protocol for secure comparison (as described in \fullref{Secure Comparison Protocol}) the companies can calculate the best performer without leaking business information. 
\textcite{Clifton2002} describe privacy preserving data mining as another use-case: data mining on patient data can for example be used to indicate disease outbreaks but there is of course a privacy concern. Using \gls{SMPC} algorithms, statistics can be computed while keeping the personal patient data private.

For \gls{SMPC} two types of adversaries have to be considered: semi-honest and malicious adversaries.
Semi-honest adversaries "follow the protocol specification, yet may attempt to learn additional information by analyzing the transcript of messages received during the execution" \autocite{Aumann2007}. Malicious adversaries "are not bound in any way to following the instructions of the specified protocol" \autocite{Aumann2007}.
\gls{SMPC} protocols that can tolerate semi-honest parties (up to a specific threshold) provide semi-honest or passive security. \gls{SMPC} protocols that are secure against malicious adversaries achieve malicious or active security.
\textcite[p. 82]{Cramer2015} also differentiate between unconditional or perfect security and computational security: if security can be proven for an adversary with unlimited computation power a protocol has unconditional security. In contrast, computational security can only be proven for a polytime adversary.

Since the target group for the protocols used in this thesis are gamification systems potential adversaries are likely of the semi-honest type. Gamification system are usually based on intrinsic motivation. Especially in the context of workplace related gamification without public recognition, there is nothing to be gained from trying to corrupt the system, only the significance of the computation results is reduced.

Honest, but curious parties are more likely, but providing the majority of semi-honest parties (which is the requirement for gaining additional information from combined shares, see \ref{Secret Sharing}), requires considerable efforts. Even if single scores are revealed, their isolated information content is almost valueless for the adversaries and targeting specific nodes over a longer amount of time adds additional complexity because of the spatial degree of freedom of the nodes (compare \ref{Mobile Ad Hoc Networks}).
Therefor, in context of gamification systems, this thesis focuses on practical \gls{SMPC} protocols for passive security based on secret sharing.

\subsection{Secret Sharing}	\label{Secret Sharing}

\textcite[p. 32]{Cramer2015} describe secret sharing schemes as the main tool to build a \gls{SMPC} protocol with passive security. In 1979 Adi Shamir described a $(k, n)$ threshold scheme for sharing secret data $D$: "Our goal is to divide $D$ into $n$ pieces $D_i$, ..., $D_n$ in such a way that:
(1) knowledge of any k or more $D_i$ pieces makes $D$ easily computable; (2) knowledge of any $k-1$ or fewer $D_i$ pieces leaves $D$ completely undetermined (in the sense that all its possible values are equally likely)" \autocite{Shamir1979}.
Shamir's secret sharing scheme is based on polynomials of degree $k-1$ with $a_0=D$ (compare \ref{eq:polynomial}). 
\begin{equation}
\label{eq:polynomial}
q(x)=\underbrace{D}_{a_0} + a_1 \cdot x + ... + a_{k-1} \cdot x^{k-1}
\end{equation}

To divide $D$ into $n$ pieces the polynomial is evaluated: $D_i=q(i),\ i=1,...,n$. For cryptographic protocols it is not practical to work with real arithmetic, instead a finite field is used: \textcite{Shamir1979} specifies that modular instead of real arithmetic is used. A prime $p$ with $p>D$, $p>n$ is selected and used to define the set $[0, p)$. "The coefficients $a_1, ..., a_{k-1}$ in $q(x)$ are randomly chosen	from a uniform distribution over the integers in $[0, p)$, and the values $D_1, ..., D_n$ are computed modulo $p$" \autocite[p. 613]{Shamir1979} (compare \ref{eq:polynomial modular}).
\begin{equation}
\label{eq:polynomial modular}
q(x) = D + a_1 \cdot x + ... + a_{k-1} \cdot x^{k-1} \mod p \qquad D,\ a_i \in [0,p)\ , \quad p \in \mathbb{P}
\end{equation}
\textcite[p. 7]{Cramer2015} declare the set restricted by $p$ as $\mathbb{Z}_p = \{0, 1, ..., p-1\}$. They also use the notion \textit{secret S} for the data to be shared and \textit{shares $s_i$} for the computed pieces of the secret.

\todo*{describe number off messages, usage of threshold as trade-off between security and performance -> START}

\todo*{describe number off messages, usage of threshold as trade-off between security and performance -> END}

The reconstruction of a secret $S$ can be done using Lagrange interpolation (compare \ref{eq:SSS lagrange interpolation}).
\begin{equation}
\label{eq:SSS lagrange interpolation}
S = \sum_i s_i \prod_{i \neq j} \frac{-x_j}{x_i-x_j} \mod p
\end{equation}
$k$ shares $s_i$ are needed to reconstruct $S$, so only the associated values for $i$ are used in the Lagrange interpolation.

\subsubsection*{Example Computation} \label{Example Computation}

Consider the following task: a secret $S=8$ is supposed to be shared among $n=4$ parties $P_i,\quad i=1,...,4$. The threshold for the number of needed shares for the reconstruction of the secret shall be $k=3$ (public).

First a prime $p$ has to be chosen, which has to be larger than the secret ($p>S$) and the number of parties ($p>n$): $p=17$ (public information)

Since $k=3$, the polynomial has a degree of $k-1=2$ (compare \ref{eq:SSS example polynomial}).
\begin{equation}
\label{eq:SSS example polynomial}
f(x) = S + a_1 \cdot x + a_2 \cdot x^2 \mod p
\end{equation}

The coefficients are selected randomly uniformly out of $\mathbb{Z}_p=\{0,1,...,p-1\}=\{0,1,...,16\}$: $a_1=13$ and $a_2=4$ and the shares $s_i$ are computed (compare \ref{eq:SSS example polynomial specific}).
\begin{alignat}{1}
& f(x) = 8 + 13 \cdot x + 4 \cdot x^2 \mod 17 \label{eq:SSS example polynomial specific} \\
&\qquad \qquad \qquad \quad \Downarrow \nonumber \\ 
& f(x_1)=f(1)=25\mod17=8=s_1 \nonumber \\
& f(x_2)=f(2)=50\mod17=16=s_2 \nonumber \\
& f(x_3)=f(3)=83\mod17=15=s_3 \nonumber \\
& f(x_4)=f(4)=124\mod17=5=s_4 \nonumber 
\end{alignat}

If for example parties $P_2$, $P_3$ and $P_4$ pool their shares, they can reconstruct the secret S using Lagrange interpolation (using also the public information: $p=17$):
\begin{alignat}{2}
& S = && \sum_i s_i \prod_{i \neq j} \frac{-x_j}{x_i - x_j } \mod 17 \qquad \qquad  with \ i,j \in \{2,3,4\} \\
& \quad && =s_2 \cdot \frac{-x_3}{x_2-x_3} \cdot \frac{-x_4}{x_2-x_4} + s_3 \cdot \frac{-x_2}{x_3-x_2} \cdot \frac{-x_4}{x_3-x_4} + s_4 \cdot \frac{-x_2}{x_4-x_2} \cdot \frac{-x_3}{x_4-x_3} \mod 17 \nonumber \\
& \quad && =16 \cdot \frac{-3}{2-3} \cdot \frac{-4}{2-4} + 15 \cdot \frac{-2}{3-2} \cdot \frac{-4}{3-4} + 5 \cdot \frac{-2}{4-2} \cdot \frac{-3}{4-3} \mod 17  \nonumber \\
& \quad && = 96-120+15 \mod 17 \nonumber \\
& \quad && = -9 \mod 17 \label{eq:SSS example negative modulo} \\
& \quad && = 8 \nonumber 
\end{alignat}
\textit{Note:} in cryptography $a \mod n$ for $a<0$ (negative dividend) is calculated by adding a multiple of  $n$ ($mn\mod n=0$), so that $m \cdot n+a>0$: e.g. $-9 \mod 17 = (\underbrace{1 \cdot 17-9}_{>0}) \mod 17$ (compare \ref{eq:SSS example negative modulo}), which resolves to: $a\mod n = n-(|a|\mod n), a<0$.

%\subsection*{Differential Privacy}
\todo*{Write about differential privacy?}

\subsection{Secure Addition Protocol} \label{Secure Addition Protocol}

For an environment with honest parties there are simple \gls{SMPC} protocols to compute the sum over shares. \textcite{Clifton2002} describe a ring based method, where the initializing party adds a random number $R$ to the secret input $s_1$ before passing it to the next node. Each node then adds its secret until the first party receives the result. By removing $R$ the party can than reconstruct the sum over all secret inputs (see figure \ref{figure:smpc sum ring}).

\begin{figure}[!htb] % h for placement here
	\caption{Simple secure sum protocol for ring} \label{figure:smpc sum ring}
	\includegraphics[scale=1.0]{figures/smpc-sum-simple-ring.png}
\end{figure}

This method is efficient ($2n$ messages for computation and announcing the sum in a $n$-node ring) but if parties collude, party $P_i$ only needs the output of $P_{i+1}$ as received by party $P_{i+2}$ to reconstruct the secret input of $P_{i+1}$. \textcite{Clifton2002} propose using shares in combination with permutation of the ring order, so neighbors change in each iteration and the number of parties in need to pool their data increases. This approach was extended in the "k-Secure Sum Protocol" \autocite{Sheikh2009}. Especially with a focus on security ($k\rightarrow n$) the permutation of the ring approaches share-exchanges between each node. To reduce the complexity through the ring permutation and motivated by the restrictions of the network (see \ref{Implementability}), for which the protocol is intended, this thesis  uses a Shamir based protocol for a fully connected mesh network. 

In \ref{Secret Sharing} it was demonstrated how a secret can be reconstructed from the shares using Lagrange interpolation. It is also possible to reconstruct the sum of secrets by using the sums of shares for a Lagrange interpolation.

Proof:

$n$ shares for $m$ secrets $s_l$:
\begin{alignat}{1}
&s_{l,i} = f_l(x_i) = s_l + \sum_{i=1}^{k-1} \alpha_{l,i} x_i^i \mod p \\
& \Leftrightarrow \begin{cases}
s_{1,i} = f_1(x_i) = & s_1 + \alpha_{1,1} x_i + \alpha_{1,2} x_i^2 + ... + \alpha_{1,k-1}x_i^{k-1} \mod p \\
&\vdots \\
s_{m,i} = f_n(x_i) = & s_n + \beta_{n,1} x_i + \beta_{n,2} x_i^2 + ... + \beta_{n,k-1}x_i^{k-1} \mod p
\end{cases} \nonumber \\
& \text{with} \ \{l \in \mathbb{N} \ | \ 1 \leq l \leq m \},
\ \{i \in \mathbb{N} \ | \ 1 \leq i \leq n \},
\ \{ p \in \mathbb{P} \ | \ p > \sum_l s_l \}, \nonumber \\
&\{ \alpha \in \mathbb{N} \ | \ 0 \leq \alpha \leq p \},
\ \{k \in \mathbb{N} \ | \ 2 < k \leq n \} \nonumber
\end{alignat}

Lagrange-interpolation for secret $s_l$:
\begin{alignat}{1}
&s_l = \sum_{i=1}^{n}s_{l,i}\prod_{i\neq j}\frac{-x_j}{x_i - x_j} \mod p \label{eq:Lagrange for s_l}
\end{alignat}
Sum $s$ over secrets $s_l$:
\begin{alignat}{1}
&s = \sum_{l=1}^{m} s_l \overset{\text{with} \ \ref{eq:Lagrange for s_l}}{=} \sum_{l=1}^{m} \sum_{i=1}^{n} s_{l,i}\prod_{i\neq j} \frac{-x_j}{x_i-x_j} \mod p \label{eq:sum over secrets}
\end{alignat}
\begin{alignat}{1}
&\text{with} \quad \sum_{i=1}^{n}\sum_{j=1}^{m}a_{ij} = \sum_{j=1}^{m}\sum_{i=1}^{n}a_{ij} \quad \text{follows for \ref{eq:sum over secrets}} \nonumber\\
&s= \underbrace{ \sum_{i=1}^n \underbrace{\sum_{l=1}^{m} s_{l,i}}_{\text{sum over shares}} \prod_{i\neq j} \frac{-x_j}{x_i-x_j} \mod p }_{\text{Lagrange-interpolation for sum over shares}}
\end{alignat}	

\subsubsection*{Example Computation}
Public information: $n=4$, $p=67$, $k=4$\par

\noindent Secrets: $s_1=13$, $s_2=27$, $s_3=17$, $s_4=1$\par

\noindent Target computation: sum $s$ over secrets $s= \sum_{i=1}^4 s_i=58$ without revealing ones secret to another party.		
\begin{alignat}{1}
s_{1,i}&=f_1(x_i)=13 + 35x + 22x^2 + 7x^3 \mod 67 \label{eq:example shares 1,i} \\
s_{2,i}&=f_2(x_i)=27 + 3x + 19x^2 \mod 67 \label{eq:example shares 2,i} \\
s_{3,i}&=f_3(x_i)=17 + 9x^2 + 27x^3 \mod 67 \label{eq:example shares 3,i} \\
s_{4,i}&=f_4(x_i)=1 + 13x + 31x^2 + 40x^3 \mod 67 \label{eq:example shares 4,i}
\end{alignat}
with $x_1=1$, $x_2=2$, $x_3=3$, $x_4=4$ follows
\begin{alignat}{7}
\overset{\ref{eq:example shares 1,i}}{\Rightarrow} s_{1,1}&=10 \quad &&s_{1,2}&&=26 \quad &&s_{1,3}&&=36 \quad  &&s_{1,4}&&=15  \nonumber \\
\overset{\ref{eq:example shares 2,i}}{\Rightarrow} s_{2,1}&=49 \quad &&s_{2,2}&&=42 \quad &&s_{2,3}&&=6 \quad &&s_{2,4}&&=8  \nonumber \\
\overset{\ref{eq:example shares 3,i}}{\Rightarrow} s_{3,1}&=53 \quad &&s_{3,2}&&=1 \quad &&s_{3,3}&&=23 \quad &&s_{3,4}&&=13  \nonumber \\
\overset{\ref{eq:example shares 4,i}}{\Rightarrow} s_{4,1}&=18 \quad &&s_{4,2}&&=2 \quad &&s_{4,3}&&=59 \quad &&s_{4,4}&&=27 \nonumber \\
\Rightarrow \sum_l s_{l,1}&=130 \quad \sum_l && s_{l,2}&&=71 \quad \sum_l && s_{l,3}&&=124 \quad \sum_l && s_{l,4}&&=63 \nonumber		
\end{alignat}
Lagrange-interpolation:
\begin{alignat}{2}
s&= &&\sum_{i=1}^{4}\sum_{l=1}^{4}s_{l,i}\prod_{i \neq j} \frac{-x_j}{x_i-x_j}\mod 67 \nonumber \\
&= &&130\frac{-2}{1-2}\frac{-3}{1-3}\frac{-4}{1-4}+71\frac{-1}{2-1}\frac{-3}{2-3}\frac{-4}{2-4} \nonumber \\
& &&+124\frac{-1}{3-1}\frac{-2}{3-2}\frac{-4}{3-4}+63\frac{-1}{4-1}\frac{-2}{4-2}\frac{-3}{4-3}\mod 67 \nonumber \\
&=&& 527 \mod 67 = 58 = \sum_{i=1}^4 s_i \label{eq:example result lagrange}
\end{alignat}
As expected, the result of the Lagrange-interpolation for the sum over shares is equal to the sum over the initial secrets (compare \ref{eq:example result lagrange}).

\subsubsection*{Protocol Description}
Assumptions:
%\vspace{-\topsep}
\begin{itemize}
	%\itemsep-0.5em
	\item number of parties $n>2$
	\item secure communication channel
	\item no malicious adversaries
	\item upper bound of sum $s \leq b$ can be estimated, so a prime $p > b$ can be chosen 
\end{itemize}
The secure addition protocol, as used in this thesis, consists of six phases:
\begin{enumerate}
	%\itemsep-0.5em
	\item The coordinator announces the number of parties for the computation and the indexation of each party.
	\item Each party $j$ sends shares $s_{j,i}$ of the secret input $s_j$ to the other parties.
	\item Each party $i$ computes the sum over the received shares $s_{j,i}$.
	\item Each party sends the computed sum to the coordinator.
	\item The coordinator reconstructs the sum over the inputs using Lagrange-interpolation.
	\item The coordinator broadcasts the reconstructed sum.
\end{enumerate}

In total $(n+3)\cdot (n-1)=n^2+2n-3$ messages are exchanged, so the traffic increases with the number of parties squared. Selecting a lower threshold for the secret reconstruction $\frac{n}{2} \leq k<n$ lowers the total messages by $\Delta_{\text{messages}}=n^2-n(k-1)$.

For a secure channel this protocol is information-theoretically secure: independent from computation power an adversary with $m_\text{leaked}<k$ shares will gain no information regarding the inputs.

\todo*{secure addition with verification \autocite{Cramer2015}; number of messages}

\subsection{Secure Comparison Protocol}	\label{Secure Comparison Protocol}
The secure comparison protocol compares the secret inputs and provides the minimum or maximum in a set without revealing the inputs or the parties holding the minimum or the maximum.

The protocol is based on the privacy preserving protocol for maximum computation as described in \textcite{Hasan2013}. The general idea is to use bit-decomposition and utilize the secure addition protocol bit-wise. In iterations the secure-sum for the bits ($0 \lor 1$) of the secrets multiplied with a random value are computed, starting from the \gls{MSB}, limited by a predefined upper bound, to the \gls{LSB}. The announced sum gives each party the information that at least one party has this bit set, if the sum is unequal zero. If a party has this bit not set itself it has a lower value and commits only zeros in the following iterations. Storing the result of each iteration, the parties can reconstruct the maximum.
For finding the minimum the protocol from \textcite{Hasan2013} needs an extension as described in \ref{Protocol Extension for Minimum Determination}: inputs are negated (using the binary operation NOT), making the minimum in the set the largest value. Afterwards the maximum is determined as described above. Finally the found maximum is negated again to reconstruct the minimum in the set.

\subsubsection{Example Computation} \label{Secure Comparison Example}

Public information: $n=3$, $p=67$, $\mathbb{Z}_p=\{1,...,p-1\}$, $k=3$, $s_i<b=64$ (upper bound for secret value range) \par
\noindent Secrets: $s_1=13$, $s_2=27$, $s_3=17$ \par

\noindent Target computation: $\min(s_i)=13$, $\max(s_i)=27$

Since $64_{10}=1000000_2$ is defined as upper bound for the secret values the \gls{MSB} is the sixth bit (second column in table \ref{table:secure maximum binary representation of secrets}).

\begin{table}[!htb]
	\centering
	\caption{Binary representation of secrets $s_i$} \label{table:secure maximum binary representation of secrets}
	\begin{tabular}{|c|l|l|l|l|l|l|}
		\hline
		Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Binary $s_{i,2}$} \\ \hline
		13                 & 0    & 0    & 1    & 1    & 0   & 1   \\ \hline
		27                 & 0    & 1    & 1    & 0    & 1   & 1   \\ \hline
		17                 & 0    & 1    & 0    & 0    & 0   & 1   \\ \hline
	\end{tabular}
\end{table}

Each party multiplies each bit with a random within $\mathbb{Z_p}$:

\begin{table}[!htb]
	\centering
	\caption{Randomized binary representation of secrets} \label{table:secure maximum randomized binary representation}
	\begin{tabular}{|c|l|l|l|l|l|l|l|l|l|l|l|l|}
		\hline
		Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Binary $s_{i,2}$}  & \multicolumn{6}{l|}{Randomized} \\ \hline
		13                 & 0    & 0    & 1    & 1    & 0   & 1 & 0    & 0    & 45    & 61    & 0   & 57   \\ \hline
		27                 & 0    & 1    & 1    & 0    & 1   & 1 & 0    & 12    & 31    & 0    & 5   & 15   \\ \hline
		17                 & 0    & 1    & 0    & 0    & 0   & 1 & 0    & 24    & 0    & 0    & 0   & 9   \\ \hline
	\end{tabular}
\end{table}

\begin{alignat}{3}
\intertext{There are six bits, therefore six rounds of secure addition ($\sum_{secure}$) are computed:}
1^{st} \ \text{round:} \quad & \sum_{secure}=0 && \Rightarrow \quad 6^{th} \ \text{bit of the maximum is} && 0 \nonumber \\
2^{nd} \ \text{round:} \quad &\sum_{secure}=36 > 0 \quad && \Rightarrow \quad 5^{th} \ \text{bit of the maximum is} \quad && 1 \nonumber \\
\intertext{Party $p_1$ disqualifies itself as the maximum (see table \ref{table:secure maximum p1 not maximum})}
3^{rd} \ \text{round:} \quad &\sum_{secure}=31 > 0 && \Rightarrow \quad 4^{th} \ \text{bit of the maximum is} && 1 \nonumber \\
\intertext{Party $p_3$ disqualifies itself as the maximum (see table \ref{table:secure maximum p3 not maximum})}
4^{th} \ \text{round:} \quad &\sum_{secure}=0 && \Rightarrow \quad 3^{rd} \ \text{bit of the maximum is} && 0 \nonumber \\
5^{th} \ \text{round:} \quad &\sum_{secure}=5>0 && \Rightarrow \quad 2^{nd} \ \text{bit of the maximum is} && 1 \nonumber \\
6^{th} \ \text{round:} \quad &\sum_{secure}=15>0 && \Rightarrow \quad 1^{st} \ \text{bit of the maximum is} && 1 \nonumber
\end{alignat}

\begin{table}[!htb]
	\centering
	\caption{$2^{nd}$ round} \label{table:secure maximum p1 not maximum}
	\begin{tabular}{|l|l|l|l|l|l|l|}
		\hline
		Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Randomized} \\ \hline
		13                 & 0    & \textcolor{red}{\underline{0}}    & $\cancelto{\textcolor{red}{0}}{45}$    & $\cancelto{\textcolor{red}{0}}{61}$    & \textcolor{red}{0}   & $\cancelto{\textcolor{red}{0}}{57}$   \\ \hline
		27                 & 0    & 12    & 31    & 0    & 5   & 15   \\ \hline
		17                 & 0    & 24    & 0    & 0    & 0   & 9   \\ \hline
	\end{tabular}
\end{table}

\begin{table}[!htb]
	\centering
	\caption{$3^{rd}$ round} \label{table:secure maximum p3 not maximum}
	\begin{tabular}{|l|l|l|l|l|l|l|}
		\hline
		Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Randomized} \\ \hline
		13                 & 0    & 0    & 0    & 0    & 0   & 0   \\ \hline
		27                 & 0    & 12    & 31    & 0    & 5   & 15   \\ \hline
		17                 & 0    & 24    & \textcolor{red}{\underline{0}}    & \textcolor{red}{0}    & \textcolor{red}{0}   & $\cancelto{\textcolor{red}{0}}{9}$   \\ \hline
	\end{tabular}
\end{table}

In total, each party has the bits $0|1|1|0|1|1$ stored and can reconstruct the correct maximum $\max(s_i)=27$.

\subsubsection{Protocol Extension for Minimum Determination} \label{Protocol Extension for Minimum Determination}

Using the negation of the binary representation, the order of the corresponding values in decimal numeral system is inverted (compare table \ref{table:secure minimum negation}). The computation is then the same as for the maximum search. The reconstructed maximum is finally negated to result in $\min(s_i)$.

\begin{table}[!htb]
	\centering
	\caption{Negation of binary representation for minimum determination} \label{table:secure minimum negation}
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|}
		\hline
		Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Binary $s_{i,2}$}  & \multicolumn{6}{l|}{Negated $\bar{s}_{i,2}$} \\ \hline
		13                 & 0    & 0    & 1    & 1    & 0   & 1 & 1    & 1    & 0    & 0    & 1   & 0   \\ \hline
		27                 & 0    & 1    & 1    & 0    & 1   & 1 & 1    & \textcolor{red}{\underline{0}} & 0    & 1    & 0   & 0   \\ \hline
		17                 & 0    & 1    & 0    & 0    & 0   & 1 & 1    & \textcolor{red}{\underline{0}} & 1    & 1    & 1   & 0   \\ \hline
	\end{tabular}
\end{table}

In the second round booth $P_2$ and $P_3$ disqualify themselves as maximum. After six rounds each party holds: $1|1|0|0|1|0$ as the maximum (see red markings in table \ref{table:secure minimum negation}). Negated this gives the minimum as $0|0|1|1|0|1_2=13_{10}$ 

\FloatBarrier

\subsubsection{Protocol Description}
Assumptions:
% \vspace{-\topsep}
\begin{itemize}
	% \itemsep-0.5em
	\item number of parties $n>2$
	\item secure communication channel
	\item no malicious adversaries
	\item upper bound of sum $s \leq b$ can be estimated, so a prime $p > b$ can be chosen 
\end{itemize}
The secure comparison protocol, as used in this thesis, consists of the phases for secure addition within iterations for the bitwise length of a predefined upper bound for the inputs: 
\begin{enumerate}
	% \itemsep-0.5em
	\item The coordinator announces the number of parties for the computation and the indexation of each party.
	\item For minimum-search: each party negates the secret input.
	\item For each bit in the secret input starting from \gls{MSB} to \gls{LSB} each party runs through iterations:
	%\vspace{-\topsep}
	\begin{enumerate}
		% \itemsep-0.5em
		\item If input is flagged as lower than maximum, then use $s_j=0$ as the input. Otherwise multiply actual bit $b$ with a random value $R$: $s_j=b \cdot R$.
		\item Each party $j$ sends shares $s_{j,i}$ of the input $s_j$ to the other parties.
		\item Each party $i$ computes the sum over the received shares $s_{j,i}$.
		\item Each party sends the computed sum to the coordinator.
		\item The coordinator reconstructs the sum over the inputs using Lagrange-interpolation.
		\item The coordinator broadcasts the reconstructed sum.
		\item Each party stores if the sum for the bit was equal 0 (set bit 0) or unequal 0 (set bit 1).
		\item Each party compares if bit from the computed sum is greater than own bit. If so input is flagged as lower than maximum.
	\end{enumerate}
	\item For minimum-search: each party negates the stored sum-result.
\end{enumerate}

Note: the assumption $n>2$ for the secure addition and secure comparison protocols is not strict enough, if sum, $\min$ and $\max$ are computed for the same parties, since for $n=3$ the secret between minimum and maximum can be restored (for a honest majority the mapping of values to parties is still secure though).

\subsection{Existing Frameworks} \label{Existing Frameworks}

In this section a short overview over existing \gls{SMPC} solutions is given. While \gls{SMPC} is an intensely researched field, practical work is less common.

The following solutions were considered

\begin{itemize}
	\item MpcLib (see \textcite{Online:MpcLib})
	\item SEPIA (see \textcite{Online:Sepia})
	\item SPDZ (see \textcite{Online:SPDZ})
	\item Sharemind (see \textcite{Online:Sharemind})
	\item Enigma (see \textcite{Online:Enigma})
\end{itemize}

Some key-features of the solutions are illustrated in figure \ref{figure:existing frameworks}. All projects emerged from university research. With the exception of Sharemind and Enigma, the frameworks seem to target primarily other researchers, reflecting in the lack of documentation and thereby reduced usability. The open-source library MpcLib is C\# based, SPDZ uses C++ and Python and SEPIA is a Java library.  Sharemind and Enigma are also booth based on university research (Enigma at MIT and Sharemind at University of Tartu) but evolved into market-ready business solutions. While Sharemind uses dedicated application-server, Enigma uses a distributed system of nodes based on Blockchain technology for \gls{SMPC}, booth with a focus on scalable secure data analysis.
All solution are based on the Internet protocol suite and require at least locally run server or Internet access.

\begin{figure}[!htb] % h for placement here
	\caption{Existing \gls{SMPC} software grouped by properties} \label{figure:existing frameworks}
	\includegraphics[scale=1.0]{figures/frameworks.png}
\end{figure}

While all frameworks exceed the requirements regarding the \gls{SMPC} functionality, they don't provide a solution for local ad-hoc networks without permanently available servers. Also the support for low-level devices is either undocumented or not given through programming language dependencies.
The development of a framework with a focus on cross-platform usage, usability for developers without cryptographic research background and applicability for local ad-hoc networks for the described gamification use-cases is therefor justified.

\FloatBarrier

\section{Mobile Ad Hoc Networks}
\label{Mobile Ad Hoc Networks}
The framework developed as part of this thesis focuses on providing \gls{SMPC} for \glspl{MANET} or \gls{MANET}-like networks. In this section the network topologies related to \glspl{MANET} are briefly described (see \ref{Network Topologies}) and the implementability based on current technology standards are examined (see \ref{Implementability}).

\subsection{Network Topologies}
\label{Network Topologies}

\textcite{Dorri2015} describe a \gls{MANET} as an "infrastructure-independent network with wireless mobile nodes" \autocite[p. 15]{Dorri2015}. \glspl{MANET} are similar to mesh networks, but the distinctive feature is the nodes' spatial degree of freedom. In comparison to a star network, there is no central switch dedicated to routing messages. Instead each node provides message passing abilities and acts as a multi-hop relay.
The advantage of \glspl{MANET} is the open network boundary: nodes can freely join and leaving nodes do not affect the functionality of the \gls{MANET}. The key-features are:

%\vspace{-\topsep}
\begin{itemize}  
	%\itemsep-0.5em
	\item continuously self-configuring
	\item self-forming
	\item self-healing
	\item infrastructure-less
	\item peer-to-peer
	\item  mobility of nodes (main difference to mesh network)
\end{itemize}

The message passing in a \gls{MANET} can either be done by routing or flooding. Since the nodes can move freely, the neighbors will change often, so maintaining routing tables is expensive. The passing of messages without the availability of authentication protocols like \gls{HTTPS} makes the communication also vulnerable against man-in-the-middle attacks. Of course flooding means broadcasting and is not cheap either in regard to message quantity and network load.

The mentioned key-features of \glspl{MANET} make it a good network choice for a gamification setting based on mobile devices (smartphones, wearables, etc.), because it promises unobtrusive usage for participants without administrative maintenance effort. In the next section the availability and the implementability for Android devices is discussed, because of Androids dominant position as the globally leading smartphone \gls{OS} with a market share of above 80\% (see \textcite{Online:Gartner2016}). 

\subsection{Implementability on Android Devices} \label{Implementability}

\glspl{MANET} are especially of interest for military applications and disaster management but they are also gaining research focus for civil usage for example in context of \gls{IoT} devices. Demonstrations of the implementability can be found for example in Open Gardens MeshKit \gls{SDK} \autocite{Online:MeshKit}, which offers \gls{MANET} abilities for Android and iOS devices and thereby forming a \gls{SPAN}. MeshKit is also the foundation for Open Gardens FireChat \autocite{Online:FireChat}, which is for example known in context of pro-democracy demonstrations. Since Android does not provide an \gls{API} for \gls{MANET} functionality on Android devices (\gls{API} 24 at the time of writing) and the MeshKit \gls{SDK} is not open source and only available through Open Gardens partner program, a simplified (but extendable) implementation of \gls{MANET}-like behavior is developed in the application layer (compare \ref{Coordinator Election}).
Both for Wi-Fi and Bluetooth based connections, there can be limitations in regard to maximum concurrent connections. Vendor specific restrictions (hardware, driver) are hard to compensate reactive at runtime, so this issue has to be addressed proactive in \ref{Architecture} \nameref{Architecture}.

\subsubsection{Bluetooth Based \gls{MANET}}

Usually Bluetooth connections with smartphones require pairing and user actions. This is not a useful process flow to build a \gls{MANET}-like network, since nodes cannot simply join.
Using the Bluetooth protocol \gls{RFCOMM} an insecure connection can be established, without the need for pairing and user interaction. \textcite{RFCOMM2012} describe \gls{RFCOMM} as the emulation of serial ports over \gls{L2CAP}, supporting the emulation of multiple ports between two devices and ports between multiple devices (device dependent).
Since multiple simultaneous connection have to share the available bandwidth per node, it takes $\frac{n}{2}$ times longer to share the same amount of data when using only one-to-one connections sequentially. For the targeted number of computation partners in this thesis, this is a tolerable overhead and practical system parameters will be evaluated in \ref{Evaluation} and \ref{Discussion}.
The Bluetooth Special Interest Group has announced mesh networking protocols for upcoming specifications \autocite{Online:BluetoothMesh}. This is very promising in regard of system provided \gls{MANET} features, though it will take time (from experience with Bluetooth LE likely years) until enough devices are equipped with compliant Bluetooth modules.

\subsubsection{Wi-Fi Based \gls{MANET}}

Situations in which we can use Wi-Fi (or \gls{GSM}) usually provide Internet access, so Wi-Fi is not the primary target technology for this thesis. Generally, the callback-based architecture of the developed framework (compare \ref{Architecture} \nameref{Architecture}) enables the usage of different wireless technologies though. Even the interconnection of \gls{MANET}-like networks is conceivable (as demonstrated with MeshKit), but it complicates the forming of the computation group (compare \ref{Coordinator Election}), because different optional channels between nodes have to be evaluated.
With Android 4.0 (\gls{API} level 14) the Wi-Fi Peer-to-Peer framework was introduced, which complies with the Wi-Fi Alliance's Wi-Fi Direct certificate program. Wi-Fi Direct states that one-to-one or group (many-to-one) connections are possible. One device acts as a group owner (soft access point), so it forms a star topology. To imitate a \gls{SPAN} with Wi-Fi Direct multi-group communication has to be provided. In \textcite{Funai2015} limitations of Android in regard of multi-group networking as well as solutions are discussed.
Other solutions (compare \textcite{Online:SPANProject}) include usage of custom kernels on rooted smartphones. Even though  demonstrations on selected devices have shown the feasibility, such system modifications neglect the target group and the intentions of this framework.

%\section{Pseudo-Random Numbers} %maybe move to implementation/secureing channel
%\label{sec:Pseudo-Random Numbers}

%\todo*{random numbers important for cryptography: selection of coefficients in secret sharing, public key generation, ...; RNG in different environments; entropy}

%https://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator

%\todo*{lib will require a callback for random number generator -> maybe mention with outlook for requirements}

\FloatBarrier

\chapter{Design} \label{Design}

\todo*{15-20\%; explains complete processing chain; explains what methods are used; for someone that wants to know what was done in detail}

Based on the findings in chapter \fullref{Background} and extended with use-cases the requirements for the framework are specified in \fullref{Requirements}. In \fullref{Decentralized, Distributed Computing} specific requirements in context of complex processes are substantiated with algorithms for decentralized, distributed computing. Finally, a draft design is presented in \fullref{Architecture}.

\section{Requirements} \label{Requirements}

In general this thesis follows the FURPS+ system for requirements as described by \textcite{Online:FURPS}: 
requirements are categorized into functional and non-functional requirements:
\begin{alignat*}{1}
& \begin{rcases*}
\mathmakebox[\widthof{\text{Supportability}}][l]{\text{Functionality}} & \quad
\end{rcases*} \mathmakebox[\widthof{\text{non-functional requirements}}][l]{\text{functional requirements}} \\
& \begin{rcases*}
\text{Usability} & \quad \\
\text{Reliability} & \quad \\
\text{Performance} & \quad \\
\text{Supportability} & \quad
\end{rcases*} \text{non-functional requirements}
\end{alignat*}

The functional and non-functional requirements are specified in \ref{Functional Requirements} and \ref{Non-Functional Requirements}. 

\subsection{Functional Requirements} \label{Functional Requirements}

Functional requirements define the functions the framework has to offer to meet the acceptance criteria. Based on chapter \fullref{Background} we can divide the requirements into two main fields: features regarding the accurate computation of the \gls{SMPC} protocols and functions required to compensate the lack of a \gls{MANET} \gls{API} and technical limitations.
Figure \ref{figure:requirements use-case node} presents the general functionality a party - respectively a node - expects from the system: especially the need for a secure channel and the limitation to run the \gls{SMPC} only with nearby computation partners is caused by the missing multi-hop capabilities.

\begin{figure}[!htb] % h for placement here
	\caption{\gls{UML} use-case diagram for the general functional requirements of a node} \label{figure:requirements use-case node}
	\includegraphics[scale=0.85]{figures/use-case-node.png}
\end{figure}

Since most functions (like the time synchronization and the multi-party computation) require the interaction between nodes, these processes need to be coordinated. In a distributed system there is no central authority, so a node has to become the temporal leader or coordinator for the duration of a process. In figure \ref{figure:requirements use-case coordinator} the processes requiring coordination are described as use-cases from the view of a temporal coordinator.

\begin{figure}[!htb] % h for placement here
	\caption{\gls{UML} use-case diagram for the functional requirements for the coordinator} \label{figure:requirements use-case coordinator}
	\includegraphics[scale=0.75]{figures/use-case-coordinator.png}
\end{figure}

Based on the use-cases functional requirements can easily be identified and specified. In table \ref{table:functional requirements} the functional requirements are stated as user-stories, alongside assumptions and targeted tests.


\begin{table}[!htb] % h for placement here
	\centering
	\caption{Functional requirements} \label{table:functional requirements}
	\begin{tabular}{|l|p{\textwidth*4/5}|}
		\toprule
		Name & \funcreq{Pairing-less Connection}\label{req:Pairing-less Connection} \\ \midrule
		Requirement & As a node I want to join the system without having to pair with other devices so that the system remains unobtrusive. \\
		Assumptions & Device has Bluetooth capabilities with \gls{RFCOMM} protocol. \\ \midrule
		Name & \funcreq{Heartbeat}\label{req:Heartbeat} \\ \midrule
		Requirement & As a node I need to inform my coordinator if my computation is running longer than expected so that the system does not assume that the process has failed. As a coordinator I need to inform all group nodes if a computation is running longer than expected. \\
		Assumptions & Hosting system provides system time. \\ \midrule
		Name & \funcreq{Non-termination Detection}\label{req:Non-termination Detection} \\ \midrule
		Requirement & As a node I must be able to detect a communication problem so that I can reset my status. \\
		Assumptions & Hosting system provides system time. \\ \midrule
		Name & \funcreq{Coordinator Election}\label{req:Coordinator Election} \\ \midrule
		Requirement & As a node I want to become coordinator for nearby nodes so that communication can be organized. \\ \midrule
		Name & \funcreq{Token-Passing}\label{req:Token-Passing} \\ \midrule
		Requirement & As coordinator I want to be able to assign a group-member to coordinate a subprocess so that direct communication between group-members can be established. \\ \midrule
		Name & \funcreq{Secure Multi-Party Computation Module}\label{req:SMPC Module} \\ \midrule
		Requirement & As a coordinator I want to form a group of fully meshed nodes and coordinate the execution of the secure addition and secure comparison protocols using a secure communication channel. \\ \todo*{visualize finding fully-meshed nearby group in mesh network}
		Assumptions & Group size $>2$. All group-members are time-synchronized and have a score within the same time-frame limits. \\
		Testability & Unit tests to proof correctness of implementation. Performance-tests with different number of computation partners and validation of result. \\ \midrule
		Name & \funcreq{Clock Synchronization}\label{req:Clock Synchronization} \\ \midrule
		Requirement & As coordinator I want to synchronize the clocks of nearby nodes so that computation results are not biased because of different time settings. \\
		Testability & Unit tests to proof correctness of implementation. \\ \midrule
		Name & \funcreq{Database Synchronization}\label{req:Database Synchronization} \\ \midrule
		Requirement & As coordinator I want to compare my database status with nearby nodes and exchange missing entries without having to compare all entries. \\
		Assumptions & Participating nodes are idle and not waiting for a computation.\\
		\bottomrule
	\end{tabular}
\end{table}

\FloatBarrier
\subsection{Non-Functional Requirements} \label{Non-Functional Requirements}

Non-functional requirements describe quality attributes the system has to comply to. Two use-cases from a developer view are illustrated in figure \ref{figure:requirements use case developer}.

\begin{figure}[!htb] % h for placement here
	\caption{\gls{UML} use case diagram for developer} \label{figure:requirements use case developer}
	\includegraphics[scale=0.85]{figures/use-case-developer.png}
\end{figure}

Based on the use-cases for developers and general demands regarding the maintainability, expandability and performance to make the framework applicable for real-life settings, non-functional requirements can be specified as listed in table \ref{table:non-functional requirements}.

\begin{table}[!htb] % h for placement here
	\centering
	\caption{Non-functional requirements} \label{table:non-functional requirements}
	\begin{tabular}{|l|p{\textwidth*4/5}|}
		\toprule
		Name & \nonfuncreq{Usability}\label{req:Usability} \\ \midrule
		Requirement & The framework shall be configurable, so that a developer using the framework can configure the settings for the \gls{SMPC}. \\ \midrule
		Name & \nonfuncreq{Maintainability}\label{req:Supportability} \\ \midrule
		Requirement & The framework shall be maintainable, so that the code and documentation make it clear for a developer what callbacks have to be implemented and how the framework can be used in an Android device. \\ \midrule
		Name & \nonfuncreq{Performance}\label{req:Performance} \\ \midrule
		Requirement & The framework shall be secure while providing enough performance, that computations can properly terminate for nodes that move at walking speed ($\approx1\frac{m}{s}$). \\ \midrule
		Name & \nonfuncreq{Expandability}\label{req:Expandability} \\ \midrule
		Requirement & The frameworks coupling with the wireless technology shall be loosely, so that the system can be extended without having to touch core functionalities regarding the \gls{SMPC}.  \\ \bottomrule
	\end{tabular}
\end{table}

\FloatBarrier

\section{Decentralized, Distributed Computing} \label{Decentralized, Distributed Computing}

While the protocols for secure addition and secure comparison and thereby the requirement \ref{req:SMPC Module} are already well-defined (compare \ref{Secret Sharing}, \ref{Secure Addition Protocol} and \ref{Secure Comparison Protocol}), other functional requirements need further methodical substantiation. \ref{req:Coordinator Election} and \ref{req:Token-Passing} are addressed in \ref{Coordinator Election}, \ref{req:Heartbeat} and \ref{req:Non-termination Detection} are discussed in \ref{Non-termination Detection}, an algorithm for \ref{req:Clock Synchronization} is provided in \ref{Clock synchronization} and finally \ref{req:Database Synchronization} is covered in \ref{Distributed Database}.

\subsection{Coordinator Election and Coordinator Role} \label{Coordinator Election}

As discussed in \fullref{Implementability} fully featured \glspl{MANET} are currently not provided and mapping it completely in the application layer is beyond the scope of this thesis. Overcoming the technical limitations, the system can be build with sequential communications instead of parallel. As stated in \fullref{Network Topologies} communication in context of \glspl{SMPC} is only done in a fully meshed subgroup of the network, which also simplifies the coordinator election.

\noindent A node will try to become the coordinator, when \nolinebreak
%\vspace{-\topsep}
\begin{enumerate}
	%\itemsep-0.5em
	\item it enters the network after longer disconnection: event driven.
	\item a new personal score is ready for \gls{SMPC}: event driven.
	\item all \gls{SMPC} computations for a score are done: event driven.
	\item an event driven attempt failed and a certain amount of time passed: timer based.
\end{enumerate}

Extending requirement \ref{req:Coordinator Election} and to avoid situations of competing nodes trying to become coordinator and thereby booth repeatedly failing because neither can acquire enough computation partners, the timer based approach is supported by the exponential backoff algorithm. \textcite[p.67]{IEEE2010} describe the exponential backoff algorithm for collision detection and retransmission: if a coordinator appointment failed (equivalent to collision detection in original description) a factor for the waiting time till the next attempt is selected uniformly random from an increasing range, reducing the probability for competing coordinator candidates. The process is outlined in form of an \gls{UML} activity diagram in figure \ref{figure:coordinator exponential backoff}.

\begin{figure}[htbp] % h for placement here
	\caption{\gls{UML} activity diagram for exponential backoff algorithm} \label{figure:coordinator exponential backoff}
	\includegraphics[scale=0.8]{figures/exponential-backoff.png}
\end{figure}

\todo*{Reduction of active connections; compare number of additional rounds needed; discuss timeouts}

In regard to the execution of the \gls{SMPC} protocols in \ref{req:SMPC Module}, the coordinator has to find a computation group. In a mesh network with routing and point-to-point encryption as displayed in figure \ref{figure:Formation of fully meshed computation group - a}, the green marked coordinator can simply broadcast a computation request and responding nodes form the computation group. Caused by the technical limitations (see \ref{Implementability}), the coordinator has to find a fully meshed group within its reach: this guarantees that each node can directly communicate with all computation partners and messages required for securing the channel are not passed through other nodes. First the coordinator $n_1$ discovers nearby nodes (see figure \ref{figure:Formation of fully meshed computation group - b}). Then a list of these devices (identified by \gls{MAC} address) is sent to every neighboring node (see $n_2$ to $n_7$ in figure \ref{figure:Formation of fully meshed computation group - c}). Each node responds with the intersection of the received device list with the own list of discovered devices (see figure \ref{figure:Formation of fully meshed computation group - d}). To reduce the payload of the responses, they only contain a list of booleans, indication if the device with the same index in the received device list is seen by the node. The coordinator then computes the maximum group of fully meshed nodes and sends computation partners an associative array assigning new 8-bit ids (see figure \ref{figure:Formation of fully meshed computation group - e}), which reduce the payload in following steps. Nearby nodes, that are not part of the computation group, receive an indicator to abort the computation. Each node in the computation group has a list of the group and the assigned ids and can exchange public keys with group members, forming a fully meshed, end-to-end encrypted group (see figure \ref{figure:Formation of fully meshed computation group - f}).

\begin{figure}[!htb] % h for placement here
	\caption{Formation of fully meshed computation group} \label{figure:Formation of fully meshed computation group}
	\centering
	\subfloat[]{%
		\includegraphics[scale=1.0]{figures/coordinator-1.png}
		\label{figure:Formation of fully meshed computation group - a}
	}%
	\hfill
	\subfloat[]{%
		\includegraphics[scale=1.0]{figures/coordinator-2.png}
		\label{figure:Formation of fully meshed computation group - b}
	}\\
	\subfloat[]{%
		\includegraphics[scale=1.0]{figures/coordinator-3.png}
		\label{figure:Formation of fully meshed computation group - c}
	}%
	\hfill
	\subfloat[]{%
		\includegraphics[scale=1.0]{figures/coordinator-4.png}
		\label{figure:Formation of fully meshed computation group - d}
	}\\
	\subfloat[]{%
		\includegraphics[scale=1.0]{figures/coordinator-5.png}
		\label{figure:Formation of fully meshed computation group - e}
	}%
	\hfill
	\subfloat[]{%
		\includegraphics[scale=1.0]{figures/coordinator-6.png}
		\label{figure:Formation of fully meshed computation group - f}
	}
\end{figure}

Since parallel message exchange for the computation group cannot be guaranteed (see \ref{Implementability}), the coordinator controls sequential message exchanges with token passing in accordance with \ref{req:Token-Passing}. For example when $n$ nodes want to exchange $n$ secrets divided into $n$ shares each, the coordinator first requests successively the shares for himself ($s_i,1$) from the other $n-1$ nodes, while transmitting his own shares ($s_1,j$) with the request. Then the communication token gets passed to the next node, which in turn requests the shares for himself from the other $n-2$ nodes while transmitting his own shares and so on. An exemplary share-exchange for $n=3$ with token-passing is illustrated in figure \ref{figure:coordinator token passing}.

\begin{figure}[!htb] % h for placement here
	\caption{\gls{UML} sequence diagram for passing of communication token t} \label{figure:coordinator token passing}
	\includegraphics[scale=1.0]{figures/token-passing-ion.png}
\end{figure}

The combination of processes with the same communication partners, single-digit bytes of payloads and short process termination is a good option to reduces the total message-occurrence in the network: for example when a coordinator requests the states of nearby nodes, it can be combined with the clock synchronization.

\FloatBarrier

\subsection{Clock Synchronization} \label{Clock synchronization}

For statistical data in a gamification system, the sequence of events in infinitesimal time units is not as important as comparing the data for the same durations in \gls{UTC}, so a synchronization of physical clocks is needed as requested in \ref{req:Clock Synchronization}. In this thesis  the well known Berkeley-algorithm for internal clock synchronization in distributed systems is used as described in \textcite{Ghosh2015}.

\noindent The coordinator
%\vspace{-\topsep}
\begin{enumerate}
	%\itemsep-0.5em
	\item requests the current time values $t_i$ from participating nearby nodes $i$.
	\item computes the average of these values $t_{average}$.
	\item reports back the adjustments $\Delta_{i}=t_{average}-t_i$
\end{enumerate}

Since the communication between the coordinator and a node takes time, the received response is already outdated. This is compensated by observing the \gls{RTT} and using half of the duration as a correction value (compare \ref{eq:berkeley RTT}). The \gls{RTT} is herein the timespan between sending a request to a node and receiving its response (see figure \ref{figure:berkeley RTT}).
\begin{alignat}{1}
t'_i &=t_i+\underbrace{\frac{RTT}{2}}_{\text{correction value}}=t_i+\frac{t_e-t_s}{2} \label{eq:berkeley RTT}
\end{alignat}

\begin{figure}[!htbp] % h for placement here
	\caption{Round Trip Time} \label{figure:berkeley RTT}
	\includegraphics[scale=1.0]{figures/berkeley-ion.png}
\end{figure}

By sending the adjustments $\Delta_i$ instead of the adjusted time, the receiving nodes do not need to compensate the received value with the \gls{RTT}. Figure \ref{figure:berkeley example} depicts the computation of the adjustments using Berkeley with \gls{RTT} correction for three nodes. 

\begin{figure}[!htbp] % h for placement here
	\caption{Example computation of adjustments with Berkeley} \label{figure:berkeley example}
	\includegraphics[scale=1.0]{figures/berkeley-example-ion.png}
\end{figure}

For further improvement of the accuracy the processing duration between receiving a request and sending the response $t_{process}$ can be measured and send to the coordinator. In this thesis the simple approximation for $t_{response}$ is used, since the additional payload extends the transmission duration. The \gls{RTT} has to be below an upper bound though, otherwise there is to much uncertainty regarding the influence of $t_{request}$, $t_{process}$ and $t_{response}$.
Also bounds for the deviation of the time can be defined to reduce the influence of outliers.

The framework does not change the actual clock setting on the hosting system, but stores the computed time difference $\Delta_t$ and applies the value to all time-related actions. To make sure that a node is time-synchronized before scores and computations are acquired, it is reasonable to trigger a synchronization when the node joins the network. 

\FloatBarrier

\subsection{Non-termination Detection} \label{Non-termination Detection}

Especially since the coordinator gives temporarily away the message token and goes into a waiting state, there has to be a protocol to detect non-termination for processes. Meeting \ref{req:Non-termination Detection} each request to another node and each local computation initializes the start of timers. The local timer triggers the transmission of a heartbeat message (compare \ref{req:Heartbeat}) to the coordinator, signaling that the process is still intact, but not yet finished. If the coordinator receives a heartbeat message, it informs the other nodes in the computation group (causing them to reset their local timers), and resets its local timeout-timer. If the coordinator reaches a limit for the timer without receiving a heartbeat message, non-termination is assumed and all group members are informed, that the computation failed. The heartbeat protocol for the coordinator waiting for response is outlined in figure \ref{figure:heartbeat coordinator}, while the protocol for a node in possession of the message token is displayed in figure \ref{figure:heartbeat node}.  

\begin{figure}[!htb] % h for placement here
	\caption{Avoidance of false non-termination detection through heartbeat messages} \label{figure:False non-termination detection with heartbeat messages}
	\centering
	\subfloat[]{%
		\includegraphics[scale=0.8]{figures/heartbeat-coordinator.png}
		\label{figure:heartbeat coordinator}
	}%
	\hfill
	\subfloat[]{%
		\includegraphics[scale=0.8]{figures/heartbeat-node.png}
		\label{figure:heartbeat node}
	}
\end{figure}

\FloatBarrier

\subsection{Distributed Databases} \label{Distributed Database}

A distributed system without central servers, that guarantee availability throughout the network, has to provide a distributed database model. This means, that nodes need to compare their database states with each other and synchronize differences. Since the nodes can enter and leave the network freely, preservation of the data in the system as well as consistency has to be considered.

The framework deals only with entry-sets of the database and lets the hosting system handle the actual storage. Since each node hosts its own database, transactions for concurrent access is not an issue.

\noindent An entry consists of:
%\vspace{-\topsep}
\begin{itemize}
	%\itemsep-0.5em
	\item Hash over the entry
	\item Unix timestamp
	\item size of computation group
	\item indicator for min, max or sum
	\item value
\end{itemize}

The combination of hash and Unix timestamp generates a key for the entry that is most likely collision free. The size of the computation group is needed to compute the arithmetic average from multiple entry-sum-values in a specified time-window: 
\begin{align*}
\begin{rcases*}
\begin{rcases*}
\mathmakebox[2.5cm][c]{ \underbrace{s_1, s_2, s_3, s_4, s_5}_{n_1=5} }  & \quad
\end{rcases*} v_1=\sum_{i}s_i \\
\begin{rcases*}
\mathmakebox[2.5cm][c]{ \underbrace{s_6, s_7, s_8}_{n_2=3} } & \quad
\end{rcases*} v_2=\sum_{i}s_i
\end{rcases*} \overline{v}_i=\frac{v_1+v_2}{n_1+n_2}
\end{align*}

Since the framework offers three types of \glspl{SMPC} the entry must reflect the source of the value. By comparison and updating, each node will have eventually all entries, so a distributed database has eventual consistency.
To meet with the requirement \ref{req:Database Synchronization} each node holds the sum of the entries' hashes within a specified time-window. This value is used to compare the database-states between nodes: if the values are equal, the databases are likely consistent (collisions are possible though but only for short durations until new \gls{SMPC} results are generated or collision free nodes are encountered), otherwise entries are compared and exchanged. First the coordinator request the hash-sum. If they match an acknowledgment is send, otherwise up to n (predefined upper bound) hashes of the entries in anti-chronological order are send in an array to the node. The node response with an array of booleans, representing if the hashes are known. If the response-array contains zeros, then the unknown entries are transmitted. After an entry-exchange the hash-sums are compared, to determine if consistency is reached (coordinator request hash-sum if needed, compare figure \ref{figure:Database synchronization scheme}). If the hash-sums do not match, the node sends up to n entry-hashes to the coordinator, skipping already evaluated entries. This is repeated until consistency is reached or a request times out and the process is aborted.
Figure \ref{figure:Database synchronization scheme} displays the basic process for $n=2$, with ASCII-values as mock-up hashes:

\begin{figure}[!htbp] % h for placement here
	\caption{Database synchronization scheme} \label{figure:Database synchronization scheme}
	\includegraphics[scale=1.0]{figures/db-synchronization-ion.png}
\end{figure}

%	\section{Applicability of \gls{SMPC} Protocols in \gls{MANET}s} \todo*{Remove Applicability chapter? More or less answered in previous/following chapters...}

%		\subsection*{Analysis of Key Factors: Computing Power, Network Data Rates and Duration of Connection}

%		\subsection*{Effectiveness of \gls{SMPC} Protocols in Sparse Networks}

%			\subsubsection*{Maintaining anonymity}

%			\subsubsection*{Strategies for Aggregation of Participants in Sparse Networks}

\FloatBarrier

\subsection{Securing the Communication Channel} \label{Securing the Communication Channel}

As requested in requirement \ref{req:SMPC Module} and noted in \ref{Secure Addition Protocol} the \gls{SMPC} protocols need secure communication channels. Listen in on wireless communication means receiving the radio signals, so for common wireless technologies this is easily accomplished. Since the physical layer is more or less public, the communication needs encryption. 
For this framework two kinds of encryption are used: first asymmetric cryptography is used to exchange a session-key, which is then used to secure messages with symmetric encryption, as displayed in figure \ref{figure:RSA/AES scheme}. This principle is well known from \gls{TLS} encryption used in \gls{HTTPS}. For the asymmetric encryption the public-key cryptosystem \acs{RSA} as described by \textcite[pp. 49-76]{Delfs2015} is used. For the symmetric encryption the \gls{AES} as described by \textcite[pp. 19-25]{Delfs2015} is used.
\gls{AES} encrypts and decrypts faster than \gls{RSA}, because \gls{RSA} requires long keys (2048 bit and longer recommended) for proper security. But \gls{AES} needs sender and receiver to know the shared/symmetric key, and the exchange of this key over an insecure channel only with \gls{AES} is not possible.

\begin{figure}[!htbp] % h for placement here
	\caption{Securing communication with \gls{RSA} and \gls{AES}} \label{figure:RSA/AES scheme}
	\includegraphics[scale=1.0]{figures/encryption-ion.png}
\end{figure}

The basis for the cryptosystem by \gls{RSA} is the prime-factorization, which requires super-polynomial time. \gls{RSA} is asymmetric, since there is one key for encryption and one key for decryption. In this setting, the public key is used for encryption, so only the receiver with the private key can decrypt the secret.
For the key generation two large prime numbers are selected: $p,q \in \mathbb{P} \ \text{with} \ p\neq q$. The product $n=p\cdot q$ is computed. Euler's Phi function $\phi (n)=(p-1)(q-1)$ is computed and a coprime integer $e$ is selected $1<e<\phi(n)$. A common value for $e$ is $65537$. The public key is formed by $n$ and $e$.
The private key is formed from $n$ and $d$, where d meets $e\cdot d\equiv 1\mod \phi(n)$.

For the symmetric encryption, booth partners use the same key. \gls{AES} is an iterated block cipher with a block length of 128 bits and key length of 128, 192 or 256 bits. The iterations (called rounds) follow the Rijndael algorithm. A detailed description of the algorithm can be found in \textcite[pp. 20-25]{Delfs2015}.

\FloatBarrier

\section{Architecture} \label{Architecture}

Based on \ref{Coordinator Election} it is sensible, that the central element in this framework is a node component. Figure \ref{figure:UML component diagram} displays the \gls{UML} component diagram for the framework design and illustrates the basic conjunctions between the components, as well as key-functionalities. The node component can also act as the coordinator and in either state communications and computations let it pass through different states of activity. This framework therefor uses the state pattern: the current state determines the behavior and abilities of the node.
In regard to the hosting system the node component utilizes an \gls{API} component, which uses callbacks to bind the communication layer and the system clock to the framework in accordance with \ref{req:Supportability}. To handle the message encryption a cryptography module is needed, providing the functionality described in \ref{Securing the Communication Channel}. As described in \ref{Non-termination Detection} a handler for timeout detection and heartbeat message triggering is provided. Parameters for communication, cryptography and \gls{SMPC} need to be accessible in a central component to meet \ref{req:Usability}.

\begin{figure}[!htbp] % h for placement here
	\caption{\gls{UML} component diagram} \label{figure:UML component diagram}
	\includegraphics[scale=1.0]{figures/uml-component.png}
\end{figure}

Since it is likely, that the technical limitations described in \ref{Implementability} will be overcome in future releases, the framework's core functionality is independent from the efforts to provide the self-forming network abilities (avoidance of code smell known as change preventer or shotgun surgery). So in case of availability of full \gls{MANET} capabilities (secure multi-hop routing and parallel communications) only the node component has to be adopted.

\todo*{state machine; state pattern; client server architecture; \gls{UML} state diagrams for 1. joining network (get time; set clock delta), 2. finding computation partners, 3. running computation, 4. compare database}

\FloatBarrier

\chapter{Implementation} \label{Implementation}

\todo*{15-20\%; details on the implementation; for someone who wants to continue the work}

%While the algorithms and protocols described in chapters \ref{Background} and \ref{Design} are language-independent, it is sensible to use C for the development, since it is widely supported on most \glspl{OS} including embedded \glspl{OS}. In this chapter the development environment and tools are introduced in \ref{Development Tools}, followed by descriptions of the implemented modules in \ref{Module Structure}. Important structures like the messages passed between nodes or the database entries are also described in \ref{Module Structure}. For the encryption of the messages the open-source library WolfCrypt is embedded (see \ref{Cryptography Module}).
%In \fullref{Interfacing the Library} the implementation tasks required for the usage of this library in a C project (in a Linux environment) as well as in an Android project are demonstrated.

\section{Development Tools}	\label{Development Tools}

\todo*{use doxygen for documentation}

\todo*{mention: development tools?}

\section{Module Structure} \label{Module Structure}

% The framework follows a modular code design: functions are separated into modules based on affiliation.

\todo*{UML class diagram}

\todo*{modular programming: separating interface from implementation}

\todo*{describe components ~documentation style}

\subsection{Node Module} \label{Node Module}

\todo*{describe the node-states: state machine in combination with state struct}

\subsubsection{Message Protocol} \label{Message Protocol}

\todo*{describe the message protocol detailed/bit level}

\todo*{describe how the library encrypts the messages; flag for message to signal encryption (first Byte of payload 0/1)}

\subsubsection{Database Entry} \label{Database Entry}

\todo*{describe the database entry struct}

% Hashing with wolfCrypt: Embedded Crypto Engine

\subsection{Non-Termination Detection Module} \label{Non-Termination Detection Module}

\todo*{change label in component diagram}

\subsection{Cryptography Module: WolfCrypt} \label{Cryptography Module}

% \gls{RSA}/\gls{AES} with wolfCrypt: Embedded Crypto Engine \textcite{Online:WolfCrypt}

\todo*{describe how external system can provide better seeds for the public key system}


\subsection{\gls{API} Module} \label{API Module}

\todo*{change label in component diagram}

\subsection{Configuration Module} \label{Configuration Module}

\subsection{\gls{SMPC} Module} \label{SMPC Module}

\todo*{describe the module for creating shares; describe generation of communication partner matrix; describe secure addition module; describe secure maximum module; describe secure minimum module}

\section{Interfacing the Library} \label{Interfacing the Library}

\todo*{external system: extend on \gls{RFCOMM}; widespread}

\subsection{Configuration} \label{Configuration}

\todo*{describe configuration.h: what can be configured, override of illegal configurations/sanity checks}

\subsection{Usage in C}	\label{Usage in C}

\todo*{describe usage of framework in a C environment with example for Linux with BlueZ stack-RFCOMM}
\todo*{describe library is used in raspberry and in xadow}

\subsection{Usage in Android} \label{Usage in Android}

\todo*{describe how library is used with android \gls{NDK}; describe Java wrapper}

\todo*{describe usage of framework in a Java environment with example for Android with Android Bluetooth API (Bluedroid stack)}

\todo*{https://developer.android.com/reference/java/security/SecureRandom.html}

\FloatBarrier

\chapter{Evaluation} \label{Evaluation}
\todo*{5-15\%; outcome; how was it tested; for supervisor}

\section{Testing Tools}	\label{Testing Tools}

\todo*{Unity (Unit test for C); JUnit; Android based multi-device tests}

\todo*{centralized client-server test application for android: trigger test runs, report results (measured execution time, correctness)}

\section{Examination of Computation Time Dependent on Computing Power} \label{Examination of Computation Time Dependent on Computing Power}

\todo*{test on: xadow (IoT); RaspberryPi 3 (SBC); Android 4 (single core, low RAM), Android 5 (multi-core, 2 GB RAM)}

\todo*{test on pc: define CPU limited processes, use pipes as communication channel, run scalability tests}

\section{Examination of Computation Time Dependent on Number of Participants} \label{Examination of Computation Time Dependent on Number of Participants}

\todo*{n devices, n shares (highest security)}

\todo*{n devices, k (>n/2) shares (adjustable security)}

%\todo*{SNET with increasing number of android devices; predefined tests}

%\section{Examination of Distribution Time Dependent on Number of Participants}

\FloatBarrier

\chapter{Discussion} \todo*{5-15\%; outcome for a design-reader} \label{Discussion}

\todo*{combine requirements with evaluation}

\todo*{extend protocol: implement merging of results, to reduce probability of not finding computation partner; implement alternative protocols}

\todo*{implement optional verification for addition, if performance is good enough for real life application}

\todo*{computation group, implement fairness: after rejection as member of computation group either reduce backoff time or raise a priority indicator a do a weighted group}

\todo*{outlook: bt 5.0, mesh network}

\todo*{extend: combine dated data to reduce storage needs; incremental hash instead of sum}

%Based on the gamification related target group, assumptions regarding the significance of dated data can be made: for example it is of interest to compare the general average for the previous year with the personal scores, maybe also on month or week level. In contrast a more fine-grained resolution of dated data will be rarely used while requiring extensive storage, compared to summarized data.

\todo*{QoS control needed}

\FloatBarrier

\chapter{Conclusion} \label{Conclusion}

\todo*{5-10\%; outcome for an introduction-reader}

\todo*{describe how statements in the introduction were met: \gls{SMPC} over self-forming, low maintenance/infrastructure-less network; framework offers reduced complexity, useful computation results for many gamification settings and other applications; performance for real life usage with good levels of security; outlook: will gain more significance for SIoT: secure Internet of things (revisit topic of insecure Internet); next steps: host public as open source to gain to use open source community to improve project further}

\clearpage
\renewcommand{\bibname}{References} % rename Bibliograpy to References
\printbibliography[heading=bibintoc] % add References chapter and display it in toc

%\begin{appendices}
%	\chapter{Some name}
%	\lipsum[3]
%\end{appendices}

%\todos

\end{document}