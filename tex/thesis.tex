\input{preamble.tex}
%\input{titlepage.tex}

\begin{document}

\newgeometry{left=3cm}
	\include{titlepage-content}
\restoregeometry

\pagenumbering{roman}

\clearpage
\vspace*{\fill}
\begin{center}
	\begin{minipage}{.8\textwidth}
		\thispagestyle{empty} % no pagenumber on affidavit
		Diese Arbeit ist von mir selbst\"andig angefertigt und verfasst. Es sind keine anderen als die angegebenen Quellen und Hilfsmittel benutzt worden.\par
		\vspace{1cm}
		Frederic Klein \dotfill \par
		Unterschrift
	\end{minipage}
\end{center}
\vfill % equivalent to \vspace{\fill}
\clearpage

\spacing{1.5} % line spacing

\begin{abstract}
	\thispagestyle{plain}
	\setcounter{page}{1}
	In recent years gamification has become a part in many areas of our daily routine. In regard to our personal life, companies like Amazon or Runtastic can base their gamification approach on publicly sharing personal achievements and statistics to improve user commitment. In contrast, gamification concerning our work life has to satisfy much higher privacy demands. Since comparison is a key component for gamification, privacy protecting computations of system wide statistical values (for example minimum and maximum) are needed. The solution comes in the form of \gls{SMPC}, a subfield of cryptography. Existing frameworks for \gls{SMPC} utilize the Internet Protocol, though access to the Internet or even a \gls{LAN} cannot be provided in all environments. Facilities with sensible measuring systems, e.g. medical devices in hospitals, often avoid Wi-Fi to reduce the risk of electromagnetic interference.
	To be able to utilize \gls{SMPC} in environments with Wi-Fi restrictions, this thesis studies the characteristics of \gls{MANET} and proposes the design of a \gls{SMPC} framework for \gls{MANET}, especially based on Bluetooth technology, and the implementation as a C library. 
	
	Since \gls{MANET}s have a \todo{bad word high acceptable here?} high probability for network partition, a centralized architecture for the computation and data preservation is unfavorable. Therefor a blockchain based distributed database is implemented in the framework. Typical problems of distributed systems are addressed with the implementation of algorithms for clock synchronization and coordinator election as well as protocols for the detection of computation partners and data distribution. Since the framework aims to provide distributed computations of comparable values, protocols for secure addition and secure comparison are implemented, enabling the computation of minimum, maximum and average.
	
	Devices of diverse computational power will be used to verify the applicability for wearables and \gls{IoT} grade devices. Also field-tests with a \gls{SPAN}(20-50 nodes) will be conducted to evaluated real life use cases. In contrast, the security of the framework and attack scenarios will be discussed. In summary, this thesis proposes a framework for \gls{SMPC} for decentralized, distributed systems.
\end{abstract}

\tableofcontents
\setcounter{page}{2}
\listoffigures
{\let\clearpage\relax \listoftables}

\printnoidxglossary[type=\acronymtype,title={List of Acronyms}]

{\let\clearpage\relax \printnoidxglossary[type=symbols,sort=letter]}

\chapter{Introduction\todo{5-10\%, including motivation, general audience}}
\pagenumbering{arabic}
In the last couple of years gamification has found it's way into many areas of our daily life. In regard to our personal life, companies like Amazon or Runtastic can base their gamification approach on publicly sharing personal achievements and statistics to improve user commitment. In contrast, gamification concerning our work life can have much higher privacy demands. Since comparison is a key component for the gamification approach, privacy protecting computations of system wide statistical values (for example minimum and maximum) are needed. The solution comes in the form of \gls{SMPC}, a subfield of cryptography.

Existing frameworks for \gls{SMPC} utilize the Internet protocol, though access to the Internet or even a \gls{LAN} cannot be provided in all environments. Especially many hospitals tend to avoid Wi-Fi to reduce the risk of electromagnetic interference with medical devices.

To be able to utilize \gls{SMPC} in environments with Wi-Fi restrictions, this thesis studies the characteristics of mesh-networks and proposes describes the design of a \gls{SMPC} framework for mesh-networks.

Context

\todo{mention \gls{IoT} problems ( \gls{DDoS} and botnets), to emphasis usefulness of connected but not online}

Restatement of the problem

Restatement of the response

Roadmap

	\section{Case Study: "The Hygiene Games"}

		\subsection*{Gamification}
	
		\subsection*{Wireless Networks in Hospitals}

\chapter{Background \todo{10-15\%; thorough review of the state of the art; informed audience}}
	
	In this chapter a general understanding of \gls{SMPC} and the key features of \gls{MANET}s is established.  
	
	First the general idea for \gls{SMPC} is introduced in \ref{sec:Secure Multi-Party Computation} \nameref{sec:Secure Multi-Party Computation}. Since secret sharing is used for the development of \gls{SMPC} protocols, Shamir's secret sharing scheme is presented in \ref{subsec:Secret Sharing} \nameref{subsec:Secret Sharing}.
	Protocols for secure addition and secure comparison with passive security are introduced in \ref{subsec:Secure Addition Protocol} and \ref{subsec:Secure Comparison Protocol} and existing frameworks for \gls{SMPC} are discussed in \ref{subsec:Existing Frameworks}.
	
	To be able to define requirements for the new framework, the key features of \gls{MANET}s are identified in \ref{sec:Mobile Ad Hoc Networks} \nameref{sec:Mobile Ad Hoc Networks}, with a focus on the wireless technology standards Bluetooth and Wi-Fi and the differences to similar network types like mesh networks.
	
	Since the \gls{SMPC} protocols expect a secure communication channel, while a pairing-less connection doesn't provide security by default, public key cryptography is needed. The key generation, as well as Shamir's secret sharing scheme, requires random numbers. Computer systems can generate pseudo-random numbers and the randomness of such an \gls{PRNG} is discussed in\ref{sec:Pseudo-Random Numbers} \nameref{sec:Pseudo-Random Numbers}.
		
	\section{Secure Multi-Party Computation}
	\label{sec:Secure Multi-Party Computation}
	
		\todo{general idea}
		\gls{SMPC} is a subfield of cryptography. The target of \gls{SMPC} is to run computations over inputs from multiple parties while keeping these inputs secret. In 1982 Yao described the problem of two millionaires trying to find out, which one is wealthier, without giving each other information about their actual capital \autocite{Yao1982}. Yao's solution for this \gls{2PC} is considered to be the basis for general \gls{SMPC} protocols. Since the target group for the protocols used in this thesis \todo{resume}
		
		\todo{use-cases to describe it better}
		
		\todo{cite \textcite{Clifton2002}: data mining; }
		
		\todo{only for honest parties, what is for other settings?} 
		
		\todo{discuss passive and active security}
		For \gls{SMPC} two types of adversaries have to be considered: semi-honest adversaries and malicious adversaries. 
		Semi-honest adversaries "follow the protocol specification, yet may attempt to learn additional information by analyzing the transcript of messages received during the execution" \autocite{Aumann2007}. Malicious adversaries "are not bound in any way to following the instructions of the specified protocol" \autocite{Aumann2007}.
		\gls{SMPC} protocols that can tolerate semi-honest parties (up to a specific threshold) provide semi-honest or passive security. \gls{SMPC} protocols that are secure against malicious adversaries achieve malicious or active security.
		\textcite[p. 82]{Cramer2015} also differentiate between unconditional or perfect security and computational security: if security can be proven for an adversary with unlimited computation power a protocol has unconditional security. In contrast, computational security can only be proven for a polytime adversary.
		
		\todo{discuss the situation for gamification: what can be gained? -> this thesis focuses on honest but curious "players" -> basic sanity checks (see ...)}
		
		\todo{simple example}

		\subsection{Secret Sharing}
		\label{subsec:Secret Sharing}
		
		\textcite[p. 32]{Cramer2015} describe secret sharing schemes as the main tool to build a \gls{SMPC} protocol with passive security. In 1979 Adi Shamir described a $(k, n)$ threshold scheme for sharing secret data $D$: "Our goal is to divide $D$ into $n$ pieces $D_i$, ..., $D_n$ in such a way that:
		(1) knowledge of any k or more $D_i$ pieces makes $D$ easily computable; (2) knowledge of any $k-1$ or fewer $D_i$ pieces leaves $D$ completely undetermined (in the sense that all its possible values are equally likely)." \autocite{Shamir1979}
		Shamir's secret sharing scheme is based on polynomials of degree $k-1$ with $a_0=D$ (compare \ref{eq:polynomial}). 
		\begin{equation}
		\label{eq:polynomial}
		q(x)=D + a_1 \cdot x + ... + a_{k-1} \cdot x^{k-1}
		\end{equation}
		
		To divide $D$ into $n$ pieces the polynomial is evaluated: $D_i=q(i),\ i=1,...,n$.
		
		For cryptographic protocols it is not practical to work with real arithmetic, instead a finite field is used. \textcite{Shamir1979} specifies that modular instead of real arithmetic is used. A prime $p$ with $p>D, p>n$ is selected and used to define the set $[0, p)$. "The coefficients $a_1, ..., a_{k-1}$ in $q(x)$ are randomly chosen	from a uniform distribution over the integers in $[0, p)$, and the values $D_1, ..., D_n$ are computed modulo $p$." \autocite[p. 613]{Shamir1979} (compare \ref{eq:polynomial modular})
		\begin{equation}
		\label{eq:polynomial modular}
		q(x) = D + a_1 \cdot x + ... + a_{k-1} \cdot x^{k-1} \mod p \qquad D,\ a_i \in [0,p)\ , \quad p \in \mathbb{P}
		\end{equation}
		\textcite[p. 7]{Cramer2015} declare the set restricted by $p$ as $\mathbb{Z}_p = \{0, 1, ..., p-1\}$. They also use the notion \textit{secret S} for the data to be shared and \textit{shares $s_i$} for the computed pieces of the secret.
		
		\todo{describe number off messages, usage of threshold as trade-off between security and performance -> START}
		
		
		
		\todo{describe number off messages, usage of threshold as trade-off between security and performance -> END}
		
				
		The reconstruction of a secret $S$ can be done using Lagrange interpolation (compare \ref{eq:SSS lagrange interpolation}).
		\begin{equation}
		\label{eq:SSS lagrange interpolation}
		S = \sum_i s_i \prod_{i \neq j} \frac{-x_j}{x_i-x_j} \mod p
		\end{equation}
		 $k$ shares $s_i$ are needed to reconstruct $S$, so only the associated values for $i$ are used in the Lagrange interpolation.
						
		\subsubsection{Example Computation}
		
		Consider the following task: a secret $S=8$ is supposed to be shared among $n=4$ parties $P_i,\quad i=0,...,3$. The threshold for the number of needed shares for the reconstruction of the secret shall be $k=3$ (public).
		
		First a prime $p$ has to be chosen, which has to be larger than the secret ($p>S$) and the number of parties ($p>n$): $p=17$ (public)
		
		Since $k=3$, the polynomial has a degree of $k-1=2$ (compare \ref{eq:SSS example polynomial}).
		\begin{equation}
		\label{eq:SSS example polynomial}
		f(x) = S + a_1 \cdot x + a_2 \cdot x^2 \mod p
		\end{equation}
		 
		 The coefficients are selected randomly uniformly out of $\mathbb{Z}_p=\{0,1,...,p-1\}=\{0,1,...,16\}$: $a_1=13$ and $a_2=4$ and the shares $s_i$ are computed (compare \ref{eq:SSS example polynomial specific}).
		 \begin{alignat}{1}
		 & f(x) = 8 + 13 \cdot x + 4 \cdot x^2 \mod 17 \label{eq:SSS example polynomial specific} \\
		 &\qquad \qquad \qquad \quad \Downarrow \nonumber \\ 
		 & f(x_1)=f(1)=25\mod17=8=s_1 \nonumber \\
		 & f(x_2)=f(2)=50\mod17=16=s_2 \nonumber \\
		 & f(x_3)=f(3)=83\mod17=15=s_3 \nonumber \\
		 & f(x_4)=f(4)=124\mod17=5=s_4 \nonumber 
		 \end{alignat}
		 
		 If parties $P_2$, $P_3$ and $P_4$ pool their shares, they can reconstruct the secret S using Lagrange interpolation (using also the public information: $p=17$):
		 \begin{alignat}{2}
		 & S = && \sum_i s_i \prod_{i \neq j} \frac{-x_j}{x_i - x_j } \mod 17 \qquad \qquad  with \ i,j \in \{2,3,4\} \\
		 & \quad && =s_2 \cdot \frac{-x_3}{x_2-x_3} \cdot \frac{-x_4}{x_2-x_4} + s_3 \cdot \frac{-x_2}{x_3-x_2} \cdot \frac{-x_4}{x_3-x_4} + s_4 \cdot \frac{-x_2}{x_4-x_2} \cdot \frac{-x_3}{x_4-x_3} \mod 17 \nonumber \\
		 & \quad && =16 \cdot \frac{-3}{2-3} \cdot \frac{-4}{2-4} + 15 \cdot \frac{-2}{3-2} \cdot \frac{-4}{3-4} + 5 \cdot \frac{-2}{4-2} \cdot \frac{-3}{4-3} \mod 17  \nonumber \\
		 & \quad && = 96-120+15 \mod 17 \nonumber \\
		 & \quad && = -9 \mod 17 \label{eq:SSS example negative modulo} \\
		 & \quad && = 8 \nonumber 
		 \end{alignat}
		 \textit{Note:} in cryptography $a \mod n$ for $a<0$ (negative dividend) is calculated by adding a multiple of  $n$, so that $m \cdot n+a>0$: e.g. $-9 \mod 17 = (\underbrace{1 \cdot 17-9}_{>0}) \mod 17$ (compare \ref{eq:SSS example negative modulo}).
		 
		%\subsection*{Differential Privacy}
		
		\todo{Write about differential privacy?}
		
		\subsection{Secure Addition Protocol}
		\label{subsec:Secure Addition Protocol}
		
		For an environment with honest parties there are simple \gls{SMPC} protocols to compute the sum over shares. \textcite{Clifton2002} describe a ring based method, where the initializing party adds a random number $R$ to the secret input $s_1$ before passing it to the next node. Each node then adds its secret until the first party receives the result. By removing $R$ the party can than reconstruct the sum over all secret inputs:
		
		\todo{visualize as svg figure}
		
		This method is efficient ($2n$ messages for computation and announcing the sum in a $n$-node ring) but if parties collude, party $P_i$ only needs the output of $P_{i+1}$ as received by party $P_{i+2}$ to reconstruct the secret input of $P_{i+1}$. \textcite{Clifton2002} propose using shares in combination with permutation of the ring order, so neighbors change in each iteration and the number of parties in need to pool their data increases. This approach was extended by \textcite{Sheikh2009} for their "k-Secure Sum Protocol".
		Using Shamir's secret sharing a 		
		In \ref{subsec:Secret Sharing} it was demonstrated how a secret can be reconstructed from the shares using Lagrange interpolation. It is also possible to reconstruct the sum of secrets by using the sums of shares for a Lagrange interpolation.
		
		Proof:
		
		$n$ shares for $m$ secrets $s_l$:
		\begin{alignat}{1}
			&s_{l,i} = f_l(x_i) = s_l + \sum_{i=1}^{k-1} \alpha_{l,i} x_i^i \mod p \\
			& \Leftrightarrow \begin{cases}
				s_{1,i} = f_1(x_i) = & s_1 + \alpha_{1,1} x_i + \alpha_{1,2} x_i^2 + ... + \alpha_{1,k-1}x_i^{k-1} \mod p \\
				&\vdots \\
				s_{m,i} = f_n(x_i) = & s_n + \beta_{n,1} x_i + \beta_{n,2} x_i^2 + ... + \beta_{n,k-1}x_i^{k-1} \mod p
			  \end{cases} \nonumber \\
			& \text{with} \ \{l \in \mathbb{N} \ | \ 1 \leq l \leq m \},
			\ \{i \in \mathbb{N} \ | \ 1 \leq i \leq n \},
			\ \{ p \in \mathbb{P} \ | \ p > \sum_l s_l \}, \nonumber \\
			&\{ \alpha \in \mathbb{N} \ | \ 0 \leq \alpha \leq p \},
			\ \{k \in \mathbb{N} \ | \ 2 < k \leq n \} \nonumber
		\end{alignat}
		
		Lagrange-interpolation for secret $s_l$:
		\begin{alignat}{1}
			&s_l = \sum_{i=1}^{n}s_{l,i}\prod_{i\neq j}\frac{-x_j}{x_i - x_j} \mod p \label{eq:Lagrange for s_l}
		\end{alignat}
		Sum $s$ over secrets $s_l$:
		\begin{alignat}{1}
			&s = \sum_{l=1}^{m} s_l \overset{\text{with} \ \ref{eq:Lagrange for s_l}}{=} \sum_{l=1}^{m} \sum_{i=1}^{n} s_{l,i}\prod_{i\neq j} \frac{-x_j}{x_i-x_j} \mod p \label{eq:sum over secrets}
		\end{alignat}
		\begin{alignat}{1}
		&\text{with} \sum_{i=1}^{n}\sum_{j=1}^{m}a_{ij} = \sum_{j=1}^{m}\sum_{i=1}^{n}a_{ij} \text{follows for \ref{eq:sum over secrets}} \nonumber\\
		&s= \underbrace{ \sum_{i=1}^n \underbrace{\sum_{l=1}^{m} s_{l,i}}_{\text{sum over shares}} \prod_{i\neq j} \frac{-x_j}{x_i-x_j} \mod p }_{\text{Lagrange-interpolation for sum over shares}}
		\end{alignat}	
		
		\subsubsection*{Example Computation}
		Public information: $n=3$, $p=67$, $k=3$\par
		
		\noindent Secrets: $s_1=13$, $s_2=27$, $s_3=17$, $s_4=1$\par
		
		\noindent Target computation: sum $s$ over secrets $s= \sum_{i=1}^4 s_i=58$ without revealing ones secret to another party.		
		\begin{alignat}{1}
			s_{1,i}&=f_1(x_i)=13 + 35x + 22x^2 + 7x^3 \mod 67 \label{eq:example shares 1,i} \\
			s_{2,i}&=f_2(x_i)=27 + 3x + 19x^2 \mod 67 \label{eq:example shares 2,i} \\
			s_{3,i}&=f_3(x_i)=17 + 9x^2 + 27x^3 \mod 67 \label{eq:example shares 3,i} \\
			s_{4,i}&=f_4(x_i)=1 + 13x + 31x^2 + 40x^3 \mod 67 \label{eq:example shares 4,i}
		\end{alignat}
		with $x_1=1$, $x_2=2$, $x_3=3$, $x_4=4$ follows
		\begin{alignat}{7}
		 \overset{\ref{eq:example shares 1,i}}{\Rightarrow} s_{1,1}&=10 \quad &&s_{1,2}&&=26 \quad &&s_{1,3}&&=36 \quad  &&s_{1,4}&&=15  \nonumber \\
		\overset{\ref{eq:example shares 2,i}}{\Rightarrow} s_{2,1}&=49 \quad &&s_{2,2}&&=42 \quad &&s_{2,3}&&=6 \quad &&s_{2,4}&&=8  \nonumber \\
		\overset{\ref{eq:example shares 3,i}}{\Rightarrow} s_{3,1}&=53 \quad &&s_{3,2}&&=1 \quad &&s_{3,3}&&=23 \quad &&s_{3,4}&&=13  \nonumber \\
		\overset{\ref{eq:example shares 4,i}}{\Rightarrow} s_{4,1}&=18 \quad &&s_{4,2}&&=2 \quad &&s_{4,3}&&=59 \quad &&s_{4,4}&&=27 \nonumber \\
		\Rightarrow \sum_l s_{l,1}&=130 \quad \sum_l && s_{l,2}&&=71 \quad \sum_l && s_{l,3}&&=124 \quad \sum_l && s_{l,4}&&=63 \nonumber		
		\end{alignat}
		Lagrange-interpolation:
		\begin{alignat}{2}
		s&= &&\sum_{i=1}^{4}\sum_{l=1}^{4}s_{l,i}\prod_{i \neq j} \frac{-x_j}{x_i-x_j}\mod 67 \nonumber \\
		 &= &&130\frac{-2}{1-2}\frac{-3}{1-3}\frac{-4}{1-4}+71\frac{-1}{2-1}\frac{-3}{2-3}\frac{-4}{2-4} \nonumber \\
		 & &&+124\frac{-1}{3-1}\frac{-2}{3-2}\frac{-4}{3-4}+63\frac{-1}{4-1}\frac{-2}{4-2}\frac{-3}{4-3}\mod 67 \nonumber \\
		 &=&& 527 \mod 67 = 58 = \sum_{i=1}^4 s_i \label{eq:example result lagrange}
		\end{alignat}
		As expected, the result of the Lagrange-interpolation for the sum over shares is equal to the sum over the initial secrets (compare \ref{eq:example result lagrange}).
		
		\subsubsection*{Protocol Description}
		Assumptions:
		\vspace{-\topsep}
		\begin{itemize}
			\itemsep-0.5em
			\item number of parties $n>2$
			\item secure communication channel
			\item no malicious adversaries
			\item upper bound of sum $s \leq b$ can be estimated, so a prime $p > b$ can be chosen 
		\end{itemize}
		The secure addition protocol, as used in this thesis, consists of six phases:
		\begin{enumerate}
		\itemsep-0.5em
		\item The coordinator announces the number of parties for the computation and the indexation of each party.
		\item Each party $j$ sends shares $s_{j,i}$ of the secret input $s_j$ to the other parties.
		\item Each party $i$ computes the sum over the received shares $s_{j,i}$.
		\item Each party sends the computed sum to the coordinator.
		\item The coordinator reconstructs the sum over the inputs using Lagrange-interpolation.
		\item The coordinator broadcasts the reconstructed sum.
		\end{enumerate}
	
	In total $(n+3)\cdot (n-1)=n^2+2n-3$ messages are exchanged, so the traffic increases with the number of parties squared. Selecting a lower threshold for the secret reconstruction $\frac{n}{2} \leq k<n$ lowers the total messages by $\Delta_{\text{messages}}=n^2-n(k-1)$.
	
	For a secure channel this protocol is information-theoretically secure: independent from computation power an adversary with $m_\text{leaked}<k$ shares will gain no information regarding the inputs. 
	
		\todo{secure addition with verification \autocite{Cramer2015}; number of messages}
		
		\subsection{Secure Comparison Protocol}
		\label{subsec:Secure Comparison Protocol}
		The secure comparison protocol compares the secret inputs and provides the minimum and the maximum in a set without revealing the the inputs or the parties holding the minimum or the maximum.
		
		The general idea: the secure comparison protocol utilizes the secure addition protocol: in iterations the secure-sum for the bits ($0 \lor 1$) of the secrets multiplied with a random value are computed, starting with the \gls{MSB} lower than a predefined upper bound till the \gls{LSB}. The announced sum gives each party the information if at least one party has this bit set, if the sum is unequal zero. If a party has this bit not set itself it has a lower value and commits only zeros to the following iterations. Storing the result of each iteration, the parties can reconstruct the maximum.
		For finding the minimum the inputs are negated (using the binary operation NOT), making the minimum in the set the largest value. Afterwards the maximum is determined as described above. Finally the found maximum is negated again to reconstruct the minimum in the set.
		
		\subsubsection*{Example Computation}
		
		Public information: $n=3$, $p=67$, $\mathbb{Z}_p=\{1,...,p-1\}$, $k=3$, $s_i<b=64$ (upper bound for secret value range) \par
		\noindent Secrets: $s_1=13$, $s_2=27$, $s_3=17$ \par
		
		\noindent Target computation: $\min(s_i)=13$, $\max(s_i)=27$
		
		Since $64_{10}=1000000_2$ is defined as upper bound for the secret values the \gls{MSB} is the sixth bit (second column in table \ref{table:secure maximum binary representation of secrets}).
		 
		\begin{table}[!htb]
			\centering
			\caption{Binary representation of secrets $s_i$}
			\label{table:secure maximum binary representation of secrets}
			\begin{tabular}{|l|l|l|l|l|l|l|}
				\hline
				Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Binary $s_{i,2}$} \\ \hline
				13                 & 0    & 0    & 1    & 1    & 0   & 1   \\ \hline
				27                 & 0    & 1    & 1    & 0    & 1   & 1   \\ \hline
				17                 & 0    & 1    & 0    & 0    & 0   & 1   \\ \hline
			\end{tabular}
		\end{table}

		Each party multiplies each bit with a random within $\mathbb{Z_p}$:
		
		\begin{table}[!htb]
			\centering
			\caption{Randomized binary representation of secrets}
			\label{table:secure maximum randomized binary representation}
			\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|}
				\hline
				Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Binary $s_{i,2}$}  & \multicolumn{6}{l|}{Randomized} \\ \hline
				13                 & 0    & 0    & 1    & 1    & 0   & 1 & 0    & 0    & 45    & 61    & 0   & 57   \\ \hline
				27                 & 0    & 1    & 1    & 0    & 1   & 1 & 0    & 12    & 31    & 0    & 5   & 15   \\ \hline
				17                 & 0    & 1    & 0    & 0    & 0   & 1 & 0    & 24    & 0    & 0    & 0   & 9   \\ \hline
			\end{tabular}
		\end{table}
				
		\begin{alignat}{3}
			\intertext{There are six bits, therefore six rounds of secure addition ($\sum_{secure}$) are computed:}
			1^{st} \ \text{round:} \quad & \sum_{secure}=0 && \Rightarrow \quad 6^{th} \ \text{bit of the maximum is} && 0 \nonumber \\
			2^{nd} \ \text{round:} \quad &\sum_{secure}=36 > 0 \quad && \Rightarrow \quad 5^{th} \ \text{bit of the maximum is} \quad && 1 \nonumber \\
			\intertext{Party $p_1$ disqualifies itself as the maximum (see table \ref{table:secure maximum p1 not maximum})}
			3^{rd} \ \text{round:} \quad &\sum_{secure}=31 > 0 && \Rightarrow \quad 4^{th} \ \text{bit of the maximum is} && 1 \nonumber \\
			\intertext{Party $p_3$ disqualifies itself as the maximum (see table \ref{table:secure maximum p3 not maximum})}
			4^{th} \ \text{round:} \quad &\sum_{secure}=0 && \Rightarrow \quad 3^{rd} \ \text{bit of the maximum is} && 0 \nonumber \\
			5^{th} \ \text{round:} \quad &\sum_{secure}=5>0 && \Rightarrow \quad 2^{nd} \ \text{bit of the maximum is} && 1 \nonumber \\
			6^{th} \ \text{round:} \quad &\sum_{secure}=15>0 && \Rightarrow \quad 1^{st} \ \text{bit of the maximum is} && 1 \nonumber
		\end{alignat}

		\begin{table}[!htb]
			\centering
			\caption{Party $p_1$ disqualifies itself as maximum in $2^{nd}$ round}
			\label{table:secure maximum p1 not maximum}
			\begin{tabular}{|l|l|l|l|l|l|l|}
				\hline
				Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Randomized} \\ \hline
				13                 & 0    & \underline{0}    & $\cancelto{0}{45}$    & $\cancelto{0}{61}$    & 0   & $\cancelto{0}{57}$   \\ \hline
				27                 & 0    & 12    & 31    & 0    & 5   & 15   \\ \hline
				17                 & 0    & 24    & 0    & 0    & 0   & 9   \\ \hline
			\end{tabular}
		\end{table}

		\begin{table}[!htb]
			\centering
			\caption{Party $p_3$ disqualifies itself as maximum in $2^{nd}$ round}
			\label{table:secure maximum p3 not maximum}
			\begin{tabular}{|l|l|l|l|l|l|l|}
				\hline
				Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Randomized} \\ \hline
				13                 & 0    & 0    & 0    & 0    & 0   & 0   \\ \hline
				27                 & 0    & 12    & 31    & 0    & 5   & 15   \\ \hline
				17                 & 0    & 24    & \underline{0}    & 0    & 0   & $\cancelto{0}{9}$   \\ \hline
			\end{tabular}
		\end{table}

		In total, each party has the bits $0|1|1|0|1|1$ stored and can reconstruct the correct maximum $\max(s_i)=27$.
		
		Using the negation of the binary representation, the order of the corresponding values in decimal numeral system is inverted (compare table \ref{table:secure minimum negation}). The computation is then the same as for the maximum search. The reconstructed maximum is finally negated to result in $\min(s_i)$.
		
		\begin{table}[!htb]
			\centering
			\caption{Negation of binary representation for minimum determination}
			\label{table:secure minimum negation}
			\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|}
				\hline
				Decimal $s_{i,10}$ & \multicolumn{6}{l|}{Binary $s_{i,2}$}  & \multicolumn{6}{l|}{Negated} \\ \hline
				13                 & 0    & 0    & 1    & 1    & 0   & 1 & 1    & 1    & 0    & 0    & 1   & 0   \\ \hline
				27                 & 0    & 1    & 1    & 0    & 1   & 1 & 1    & 0    & 0    & 1    & 0   & 0   \\ \hline
				17                 & 0    & 1    & 0    & 0    & 0   & 1 & 1    & 0    & 1    & 1    & 1   & 0   \\ \hline
			\end{tabular}
		\end{table}

		\todo{example computation}
		
		\subsubsection*{Protocol Description}
		Assumptions:
		\vspace{-\topsep}
		\begin{itemize}
			\itemsep-0.5em
			\item number of parties $n>2$
			\item secure communication channel
			\item no malicious adversaries
			\item upper bound of sum $s \leq b$ can be estimated, so a prime $p > b$ can be chosen 
		\end{itemize}
		The secure comparison protocol, as used in this thesis, consists of the phases for secure addition within iterations for the bitwise length of a predefined upper bound for the inputs: 
		\begin{enumerate}
			\itemsep-0.5em
			\item The coordinator announces the number of parties for the computation and the indexation of each party.
			\item For minimum-search: each party negates the secret input.
			\item For each bit in the secret input starting from \gls{MSB} to \gls{LSB} each party runs through iterations:
			\vspace{-\topsep}
			\begin{enumerate}
				\itemsep-0.5em
				\item If input is flagged as lower than maximum, then use $s_j=0$ as the input. Otherwise multiply actual bit $b$ with a random value $R$: $s_j=b \cdot R$.
				\item Each party $j$ sends shares $s_{j,i}$ of the input $s_j$ to the other parties.
				\item Each party $i$ computes the sum over the received shares $s_{j,i}$.
				\item Each party sends the computed sum to the coordinator.
				\item The coordinator reconstructs the sum over the inputs using Lagrange-interpolation.
				\item The coordinator broadcasts the reconstructed sum.
				\item Each party stores if the sum for the bit was equal 0 (set bit 0) or unequal 0 (set bit 1).
				\item Each party compares if bit from the computed sum is greater than own bit. If so input is flagged as lower than maximum.
			\end{enumerate}
			\item For minimum-search: each party negates the stored sum-result.
		\end{enumerate}
	
		Note: the assumption $n>2$ for the secure addition and secure comparison protocols is not strict enough, if sum, $\min$ and $\max$ are computed for the same parties, since for $n=3$ the secret between minimum and maximum can be restored (the mapping of values to parties is still secure though).
		
		\subsection{Existing Frameworks}
		\label{subsec:Existing Frameworks}
		
		 \href{http://www.brics.dk/SMCL/}{SMCL} discontinued -> \href{http://viff.dk/}{VIFF} discontinued -> SPDZ
		
		\todo{maybe: mention \href{http://www.cs.huji.ac.il/project/Fairplay/FairplayMP.html}{FairplayMP}, but also abandoned, issue from 2015 unanswered}
		
		\subsubsection*{SPDZ Software}
		\todo{SPDZ Software}
		\href{https://www.cs.bris.ac.uk/Research/CryptographySecurity/SPDZ/\#software}{link}
		
		\subsubsection*{SEPIA}
		\todo{SEPIA Java lib}
		\href{http://www.sepia.ee.ethz.ch/}{link}
		
		\subsubsection*{MpcLib}
		\todo{MpcLib: no documentation}
		\href{https://github.com/mahdiz/mpclib}{link}	
		
		\subsubsection*{Sharemind}
		\todo{sharemind}
		\href{https://sharemind.cyber.ee//}{link}	

	
	\section{Mobile Ad Hoc Networks}
	\label{sec:Mobile Ad Hoc Networks}
	
	\todo{differences between mesh and MANET}
	
			{\color{gray} 
				\begin{itemize}  
					\item continuously self-configuring
					\item self-forming
					\item self-healing
					\item infrastructure-less
					\item peer-to-peer
					\item Difference to mesh: mobility of nodes
				\end{itemize}
			}
	
		\todo{Example: firechat in SPAN}
		
			\subsection{Comparison to Wi-Fi Direct}
			
				{\color{gray} 
					\begin{itemize}  
						\item SPAN support multi-hop relays
						\item Wi-Fi Direct since Android 4.0
						\item Wi-Fi Direct: Soft AP 
					\end{itemize}
				}
		
			\subsection{Bluetooth Based \gls{MANET} }

			\subsection{Wi-Fi Based \gls{MANET}}
			
			\todo{mention https://github.com/ProjectSPAN/android-manet-manager kernel changes needed for manet}
			
		\section{Pseudo-Random Numbers}
		\label{sec:Pseudo-Random Numbers}
			
		\todo{random numbers important for cryptography: selection of coefficients in secret sharing, public key generation, ...; RNG in different environments; entropy}
			
		%https://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator
			
		\todo{lib will require a callback for random number generator -> maybe mention with outlook for requirements}
	
\chapter{Design \todo{15-20\%; explains complete processing chain; explains what methods are used; for someone that wants to know what was done in detail}}

	\section{Requirements}
	
		\todo{use cases, process description, resulting requirements}
		
		

	\section{Distributed Computing}

		\subsection*{Coordinator Election}
		
		\todo{exponential back-off + heartbeat}
		
		\subsection*{Clock Synchronization}
		
		\todo{berkeley algorithm}
		
		\subsection*{Distributed Databases}
		
	\section{Applicability of \gls{SMPC} Protocols in \gls{MANET}s}
	
		\subsection*{Analysis of Key Factors: Computing Power, Network Data Rates and Duration of Connection}
		
		\subsection*{Effectiveness of \gls{SMPC} Protocols in Sparse Networks}
		
			\subsubsection*{Maintaining anonymity}
		
			\subsubsection*{Strategies for Aggregation of Participants in Sparse Networks}
			
	\section{Architecture}
	
			\todo{UML; module structure}

\chapter{Implementation \todo{15-20\%; details on the implementation; for someone who wants to continue the work}}	

	%\section{Development Tools}
	
	\section{Communication Layer}
	
			\subsection*{Pairing-less Connection}
			
			\subsection*{Secure Channel}
			
			\todo{https://developer.android.com/reference/java/security/SecureRandom.html}
			
	\section{\gls{SMPC} Module}
	
	\section{Data Storage and Distribution}
	
	\section{Interfacing the Library}
	
		\subsection*{Configuration}
		
		\subsection*{Usage in C}
		
		\subsection*{Usage in Android}
		
\chapter{Evaluation \todo{5-15\%; outcome; how was it tested; for supervisor}}

	\section{Testing Tools}
	
		\todo{Unity (Unit test for C); JUnit; Simulation?}
		
		\todo{centralized client-server test application for android: trigger test runs, report results (measured execution time, correctness)}

	\section{Examination of Computation Time Dependent on Computing Power}
	
	\section{Examination of Computation Time Dependent on Number of Participants}
	
		%\todo{SNET with increasing number of android devices; predefined tests}
		
	%\section{Examination of Distribution Time Dependent on Number of Participants}

\chapter{Discussion \todo{5-15\%; outcome for a design-reader} }

\todo{extend protocol: implement merging of results, to reduce probability of not finding computation partner; implement alternative protocols}

\todo{implement optional verification for addition, if performance is good enough for real life application}

\chapter{Conclusion \todo{5-10\%; outcome for a introduction-reader}}

\todo{outlook: bt 5.0, mesh network}

\clearpage
\renewcommand{\bibname}{References} % rename Bibliograpy to References
\printbibliography[heading=bibintoc] % add References chapter and display it in toc

\begin{appendices}
	\chapter{Some name}
	\lipsum[3]
\end{appendices}

\end{document}